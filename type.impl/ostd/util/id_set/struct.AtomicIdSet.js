(function() {
    var type_impls = Object.fromEntries([["ostd",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AtomicIdSet%3CI%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/ostd/util/id_set.rs.html#360-431\">Source</a><a href=\"#impl-AtomicIdSet%3CI%3E\" class=\"anchor\">ยง</a><h3 class=\"code-header\">impl&lt;I: <a class=\"trait\" href=\"ostd/util/id_set/trait.Id.html\" title=\"trait ostd::util::id_set::Id\">Id</a>&gt; <a class=\"struct\" href=\"ostd/util/id_set/struct.AtomicIdSet.html\" title=\"struct ostd::util::id_set::AtomicIdSet\">AtomicIdSet</a>&lt;I&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method\"><a class=\"src rightside\" href=\"src/ostd/util/id_set.rs.html#362-368\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ostd/util/id_set/struct.AtomicIdSet.html#tymethod.new\" class=\"fn\">new</a>(value: <a class=\"struct\" href=\"ostd/util/id_set/struct.IdSet.html\" title=\"struct ostd::util::id_set::IdSet\">IdSet</a>&lt;I&gt;) -&gt; Self</h4></section></summary><div class=\"docblock\"><p>Creates a new <code>AtomicIdSet</code> from an <code>IdSet</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.load\" class=\"method\"><a class=\"src rightside\" href=\"src/ostd/util/id_set.rs.html#380-393\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ostd/util/id_set/struct.AtomicIdSet.html#tymethod.load\" class=\"fn\">load</a>(&amp;self, ordering: Ordering) -&gt; <a class=\"struct\" href=\"ostd/util/id_set/struct.IdSet.html\" title=\"struct ostd::util::id_set::IdSet\">IdSet</a>&lt;I&gt;</h4></section></summary><div class=\"docblock\"><p>Loads the value of the set with the given ordering.</p>\n<p>This operation is not atomic. When racing with a <a href=\"ostd/util/id_set/struct.AtomicIdSet.html#method.store\" title=\"method ostd::util::id_set::AtomicIdSet::store\"><code>Self::store</code></a>\noperation, this load may return a set that contains a portion of the\nnew value and a portion of the old value. Load on each specific\nword is atomic, and follows the specified ordering.</p>\n<p>Note that load with [<code>Ordering::Release</code>] is a valid operation, which\nis different from the normal atomic operations. When coupled with\n[<code>Ordering::Release</code>], it actually performs <code>fetch_or(0, Release)</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.store\" class=\"method\"><a class=\"src rightside\" href=\"src/ostd/util/id_set.rs.html#401-405\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ostd/util/id_set/struct.AtomicIdSet.html#tymethod.store\" class=\"fn\">store</a>(&amp;self, value: &amp;<a class=\"struct\" href=\"ostd/util/id_set/struct.IdSet.html\" title=\"struct ostd::util::id_set::IdSet\">IdSet</a>&lt;I&gt;, ordering: Ordering)</h4></section></summary><div class=\"docblock\"><p>Stores a new value to the set with the given ordering.</p>\n<p>This operation is not atomic. When racing with a <a href=\"ostd/util/id_set/struct.AtomicIdSet.html#method.load\" title=\"method ostd::util::id_set::AtomicIdSet::load\"><code>Self::load</code></a>\noperation, that load may return a set that contains a portion of the\nnew value and a portion of the old value. Load on each specific\nword is atomic, and follows the specified ordering.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.add\" class=\"method\"><a class=\"src rightside\" href=\"src/ostd/util/id_set.rs.html#408-414\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ostd/util/id_set/struct.AtomicIdSet.html#tymethod.add\" class=\"fn\">add</a>(&amp;self, id: I, ordering: Ordering)</h4></section></summary><div class=\"docblock\"><p>Atomically adds an ID with the given ordering.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove\" class=\"method\"><a class=\"src rightside\" href=\"src/ostd/util/id_set.rs.html#417-423\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ostd/util/id_set/struct.AtomicIdSet.html#tymethod.remove\" class=\"fn\">remove</a>(&amp;self, id: I, ordering: Ordering)</h4></section></summary><div class=\"docblock\"><p>Atomically removes an ID with the given ordering.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.contains\" class=\"method\"><a class=\"src rightside\" href=\"src/ostd/util/id_set.rs.html#426-430\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ostd/util/id_set/struct.AtomicIdSet.html#tymethod.contains\" class=\"fn\">contains</a>(&amp;self, id: I, ordering: Ordering) -&gt; bool</h4></section></summary><div class=\"docblock\"><p>Atomically checks if the set contains the specified ID.</p>\n</div></details></div></details>",0,"ostd::cpu::id::set::AtomicCpuSet"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-AtomicIdSet%3CI%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/ostd/util/id_set.rs.html#351\">Source</a><a href=\"#impl-Debug-for-AtomicIdSet%3CI%3E\" class=\"anchor\">ยง</a><h3 class=\"code-header\">impl&lt;I: Debug&gt; Debug for <a class=\"struct\" href=\"ostd/util/id_set/struct.AtomicIdSet.html\" title=\"struct ostd::util::id_set::AtomicIdSet\">AtomicIdSet</a>&lt;I&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/ostd/util/id_set.rs.html#351\">Source</a><a href=\"#method.fmt\" class=\"anchor\">ยง</a><h4 class=\"code-header\">fn <a class=\"fn\">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details>","Debug","ostd::cpu::id::set::AtomicCpuSet"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[5960]}