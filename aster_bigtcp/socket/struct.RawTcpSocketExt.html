<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `RawTcpSocketExt` struct in crate `aster_bigtcp`."><title>RawTcpSocketExt in aster_bigtcp::socket - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="aster_bigtcp" data-themes="" data-resource-suffix="" data-rustdoc-version="1.94.0-nightly (1aa9bab4e 2025-12-05)" data-channel="nightly" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">RawTcpSocketExt</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../aster_bigtcp/index.html">aster_<wbr>bigtcp</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">RawTcp<wbr>Socket<wbr>Ext</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.is_closing" title="is_closing">is_closing</a></li><li><a href="#method.is_recv_shut" title="is_recv_shut">is_recv_shut</a></li><li><a href="#method.is_rst_closed" title="is_rst_closed">is_rst_closed</a></li><li><a href="#method.may_recv_new" title="may_recv_new">may_recv_new</a></li></ul><h3><a href="#deref-methods-Socket%3C'static%3E">Methods from Deref&lt;<wbr>Target=<wbr>Socket&lt;'static&gt;&gt;</a></h3><ul class="block deref-methods"><li><a href="#method.abort" title="abort">abort</a></li><li><a href="#method.accepts" title="accepts">accepts</a></li><li><a href="#method.ack_delay" title="ack_delay">ack_delay</a></li><li><a href="#method.can_recv" title="can_recv">can_recv</a></li><li><a href="#method.can_send" title="can_send">can_send</a></li><li><a href="#method.close" title="close">close</a></li><li><a href="#method.congestion_control" title="congestion_control">congestion_control</a></li><li><a href="#method.connect" title="connect">connect</a></li><li><a href="#method.dispatch" title="dispatch">dispatch</a></li><li><a href="#method.hop_limit" title="hop_limit">hop_limit</a></li><li><a href="#method.is_active" title="is_active">is_active</a></li><li><a href="#method.is_listening" title="is_listening">is_listening</a></li><li><a href="#method.is_open" title="is_open">is_open</a></li><li><a href="#method.keep_alive" title="keep_alive">keep_alive</a></li><li><a href="#method.listen" title="listen">listen</a></li><li><a href="#method.listen_endpoint" title="listen_endpoint">listen_endpoint</a></li><li><a href="#method.local_endpoint" title="local_endpoint">local_endpoint</a></li><li><a href="#method.may_recv" title="may_recv">may_recv</a></li><li><a href="#method.may_send" title="may_send">may_send</a></li><li><a href="#method.nagle_enabled" title="nagle_enabled">nagle_enabled</a></li><li><a href="#method.peek" title="peek">peek</a></li><li><a href="#method.peek_slice" title="peek_slice">peek_slice</a></li><li><a href="#method.poll_at" title="poll_at">poll_at</a></li><li><a href="#method.process" title="process">process</a></li><li><a href="#method.recv" title="recv">recv</a></li><li><a href="#method.recv_capacity" title="recv_capacity">recv_capacity</a></li><li><a href="#method.recv_queue" title="recv_queue">recv_queue</a></li><li><a href="#method.recv_slice" title="recv_slice">recv_slice</a></li><li><a href="#method.remote_endpoint" title="remote_endpoint">remote_endpoint</a></li><li><a href="#method.send" title="send">send</a></li><li><a href="#method.send_capacity" title="send_capacity">send_capacity</a></li><li><a href="#method.send_queue" title="send_queue">send_queue</a></li><li><a href="#method.send_slice" title="send_slice">send_slice</a></li><li><a href="#method.set_ack_delay" title="set_ack_delay">set_ack_delay</a></li><li><a href="#method.set_congestion_control" title="set_congestion_control">set_congestion_control</a></li><li><a href="#method.set_hop_limit" title="set_hop_limit">set_hop_limit</a></li><li><a href="#method.set_keep_alive" title="set_keep_alive">set_keep_alive</a></li><li><a href="#method.set_nagle_enabled" title="set_nagle_enabled">set_nagle_enabled</a></li><li><a href="#method.set_timeout" title="set_timeout">set_timeout</a></li><li><a href="#method.set_tsval_generator" title="set_tsval_generator">set_tsval_generator</a></li><li><a href="#method.state" title="state">state</a></li><li><a href="#method.timeout" title="timeout">timeout</a></li><li><a href="#method.timestamp_enabled" title="timestamp_enabled">timestamp_enabled</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Deref-for-RawTcpSocketExt%3CE%3E" title="Deref">Deref</a></li><li><a href="#impl-DerefMut-for-RawTcpSocketExt%3CE%3E" title="DerefMut">DerefMut</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-RawTcpSocketExt%3CE%3E" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-RawTcpSocketExt%3CE%3E" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Freeze-for-RawTcpSocketExt%3CE%3E" title="Freeze">Freeze</a></li><li><a href="#impl-Send-for-RawTcpSocketExt%3CE%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-RawTcpSocketExt%3CE%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-RawTcpSocketExt%3CE%3E" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-Conv-for-T" title="Conv">Conv</a></li><li><a href="#impl-FmtForward-for-T" title="FmtForward">FmtForward</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-Pipe-for-T" title="Pipe">Pipe</a></li><li><a href="#impl-Pointee-for-T" title="Pointee">Pointee</a></li><li><a href="#impl-Receiver-for-P" title="Receiver">Receiver</a></li><li><a href="#impl-SameAs%3CT%3E-for-T" title="SameAs&#60;T&#62;">SameAs&#60;T&#62;</a></li><li><a href="#impl-Tap-for-T" title="Tap">Tap</a></li><li><a href="#impl-TryConv-for-T" title="TryConv">TryConv</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In aster_<wbr>bigtcp::<wbr>socket</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">aster_bigtcp</a>::<wbr><a href="index.html">socket</a></div><h1>Struct <span class="struct">RawTcp<wbr>Socket<wbr>Ext</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/aster_bigtcp/socket/bound/tcp_conn.rs.html#43-51">Source</a> </span></div><pre class="rust item-decl"><code>pub struct RawTcpSocketExt&lt;E: <a class="trait" href="../ext/trait.Ext.html" title="trait aster_bigtcp::ext::Ext">Ext</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-RawTcpSocketExt%3CE%3E" class="impl"><a class="src rightside" href="../../src/aster_bigtcp/socket/bound/tcp_conn.rs.html#67-109">Source</a><a href="#impl-RawTcpSocketExt%3CE%3E" class="anchor">§</a><h3 class="code-header">impl&lt;E: <a class="trait" href="../ext/trait.Ext.html" title="trait aster_bigtcp::ext::Ext">Ext</a>&gt; <a class="struct" href="struct.RawTcpSocketExt.html" title="struct aster_bigtcp::socket::RawTcpSocketExt">RawTcpSocketExt</a>&lt;E&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.may_recv_new" class="method"><a class="src rightside" href="../../src/aster_bigtcp/socket/bound/tcp_conn.rs.html#75-83">Source</a><h4 class="code-header">pub fn <a href="#method.may_recv_new" class="fn">may_recv_new</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Checks if the socket may receive any new data.</p>
<p>This is similar to [<code>RawTcpSocket::may_recv</code>]. However, this method checks if there can be
<em>new</em> data. In other words, if there is already buffered data in the socket,
[<code>RawTcpSocket::may_recv</code>] will always return true since it is possible to receive the
buffered data, but this method may return false if the peer has closed its sending half (so
no new data can come in).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_closing" class="method"><a class="src rightside" href="../../src/aster_bigtcp/socket/bound/tcp_conn.rs.html#89-92">Source</a><h4 class="code-header">pub fn <a href="#method.is_closing" class="fn">is_closing</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Checks if the socket is closing.</p>
<p>More specifically, we say a socket is closing if and only if it has sent its FIN packet but
is still waiting for an ACK packet from the peer to acknowledge the FIN it sent.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_recv_shut" class="method"><a class="src rightside" href="../../src/aster_bigtcp/socket/bound/tcp_conn.rs.html#98-100">Source</a><h4 class="code-header">pub fn <a href="#method.is_recv_shut" class="fn">is_recv_shut</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Returns whether the receiving half of the socket is shut down.</p>
<p>This method will return true if and only if [<code>TcpConnection::shut_recv</code>] or
[<code>TcpConnection::close</code>] is called.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_rst_closed" class="method"><a class="src rightside" href="../../src/aster_bigtcp/socket/bound/tcp_conn.rs.html#106-108">Source</a><h4 class="code-header">pub fn <a href="#method.is_rst_closed" class="fn">is_rst_closed</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Checks if the socket is closed by a RST packet.</p>
<p>Note that the flag is automatically cleared when it is read by
[<code>TcpConnection::clear_rst_closed</code>], [<code>TcpConnection::send</code>], or [<code>TcpConnection::recv</code>].</p>
</div></details></div></details></div><details class="toggle big-toggle" open><summary><h2 id="deref-methods-Socket%3C'static%3E" class="section-header"><span>Methods from Deref&lt;Target = Socket&lt;'static&gt;&gt;</span><a href="#deref-methods-Socket%3C'static%3E" class="anchor">§</a></h2></summary><div id="deref-methods-Socket%3C'static%3E-1" class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.set_tsval_generator" class="method"><h4 class="code-header">pub fn <a href="#method.set_tsval_generator" class="fn">set_tsval_generator</a>(&amp;mut self, generator: Option&lt;fn() -&gt; u32&gt;)</h4></section></summary><div class="docblock"><p>Enable or disable TCP Timestamp.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timestamp_enabled" class="method"><h4 class="code-header">pub fn <a href="#method.timestamp_enabled" class="fn">timestamp_enabled</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Return whether TCP Timestamp is enabled.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_congestion_control" class="method"><h4 class="code-header">pub fn <a href="#method.set_congestion_control" class="fn">set_congestion_control</a>(&amp;mut self, congestion_control: CongestionControl)</h4></section></summary><div class="docblock"><p>Set an algorithm for congestion control.</p>
<p><code>CongestionControl::None</code> indicates that no congestion control is applied.
Options <code>CongestionControl::Cubic</code> and <code>CongestionControl::Reno</code> are also available.
To use Reno and Cubic, please enable the <code>socket-tcp-reno</code> and <code>socket-tcp-cubic</code> features
in the <code>smoltcp</code> crate, respectively.</p>
<p><code>CongestionControl::Reno</code> is a classic congestion control algorithm valued for its simplicity.
Despite having a lower algorithmic complexity than <code>Cubic</code>,
it is less efficient in terms of bandwidth usage.</p>
<p><code>CongestionControl::Cubic</code> represents a modern congestion control algorithm designed to
be more efficient and fair compared to <code>CongestionControl::Reno</code>.
It is the default choice for Linux, Windows, and macOS.
<code>CongestionControl::Cubic</code> relies on double precision (<code>f64</code>) floating point operations, which may cause issues in some contexts:</p>
<ul>
<li>Small embedded processors (such as Cortex-M0, Cortex-M1, and Cortex-M3) do not have an FPU, and floating point operations consume significant amounts of CPU time and Flash space.</li>
<li>Interrupt handlers should almost always avoid floating-point operations.</li>
<li>Kernel-mode code on desktop processors usually avoids FPU operations to reduce the penalty of saving and restoring FPU registers.</li>
</ul>
<p>In all these cases, <code>CongestionControl::Reno</code> is a better choice of congestion control algorithm.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.congestion_control" class="method"><h4 class="code-header">pub fn <a href="#method.congestion_control" class="fn">congestion_control</a>(&amp;self) -&gt; CongestionControl</h4></section></summary><div class="docblock"><p>Return the current congestion control algorithm.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timeout" class="method"><h4 class="code-header">pub fn <a href="#method.timeout" class="fn">timeout</a>(&amp;self) -&gt; Option&lt;<a class="struct" href="../time/struct.Duration.html" title="struct aster_bigtcp::time::Duration">Duration</a>&gt;</h4></section></summary><div class="docblock"><p>Return the timeout duration.</p>
<p>See also the <a href="#method.set_timeout">set_timeout</a> method.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ack_delay" class="method"><h4 class="code-header">pub fn <a href="#method.ack_delay" class="fn">ack_delay</a>(&amp;self) -&gt; Option&lt;<a class="struct" href="../time/struct.Duration.html" title="struct aster_bigtcp::time::Duration">Duration</a>&gt;</h4></section></summary><div class="docblock"><p>Return the ACK delay duration.</p>
<p>See also the <a href="#method.set_ack_delay">set_ack_delay</a> method.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.nagle_enabled" class="method"><h4 class="code-header">pub fn <a href="#method.nagle_enabled" class="fn">nagle_enabled</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Return whether Nagle’s Algorithm is enabled.</p>
<p>See also the <a href="#method.set_nagle_enabled">set_nagle_enabled</a> method.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_timeout" class="method"><h4 class="code-header">pub fn <a href="#method.set_timeout" class="fn">set_timeout</a>(&amp;mut self, duration: Option&lt;<a class="struct" href="../time/struct.Duration.html" title="struct aster_bigtcp::time::Duration">Duration</a>&gt;)</h4></section></summary><div class="docblock"><p>Set the timeout duration.</p>
<p>A socket with a timeout duration set will abort the connection if either of the following
occurs:</p>
<ul>
<li>After a <a href="#method.connect">connect</a> call, the remote endpoint does not respond within
the specified duration;</li>
<li>After establishing a connection, there is data in the transmit buffer and the remote
endpoint exceeds the specified duration between any two packets it sends;</li>
<li>After enabling <a href="#method.set_keep_alive">keep-alive</a>, the remote endpoint exceeds
the specified duration between any two packets it sends.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_ack_delay" class="method"><h4 class="code-header">pub fn <a href="#method.set_ack_delay" class="fn">set_ack_delay</a>(&amp;mut self, duration: Option&lt;<a class="struct" href="../time/struct.Duration.html" title="struct aster_bigtcp::time::Duration">Duration</a>&gt;)</h4></section></summary><div class="docblock"><p>Set the ACK delay duration.</p>
<p>By default, the ACK delay is set to 10ms.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_nagle_enabled" class="method"><h4 class="code-header">pub fn <a href="#method.set_nagle_enabled" class="fn">set_nagle_enabled</a>(&amp;mut self, enabled: bool)</h4></section></summary><div class="docblock"><p>Enable or disable Nagle’s Algorithm.</p>
<p>Also known as “tinygram prevention”. By default, it is enabled.
Disabling it is equivalent to Linux’s TCP_NODELAY flag.</p>
<p>When enabled, Nagle’s Algorithm prevents sending segments smaller than MSS if
there is data in flight (sent but not acknowledged). In other words, it ensures
at most only one segment smaller than MSS is in flight at a time.</p>
<p>It ensures better network utilization by preventing sending many very small packets,
at the cost of increased latency in some situations, particularly when the remote peer
has ACK delay enabled.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.keep_alive" class="method"><h4 class="code-header">pub fn <a href="#method.keep_alive" class="fn">keep_alive</a>(&amp;self) -&gt; Option&lt;<a class="struct" href="../time/struct.Duration.html" title="struct aster_bigtcp::time::Duration">Duration</a>&gt;</h4></section></summary><div class="docblock"><p>Return the keep-alive interval.</p>
<p>See also the <a href="#method.set_keep_alive">set_keep_alive</a> method.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_keep_alive" class="method"><h4 class="code-header">pub fn <a href="#method.set_keep_alive" class="fn">set_keep_alive</a>(&amp;mut self, interval: Option&lt;<a class="struct" href="../time/struct.Duration.html" title="struct aster_bigtcp::time::Duration">Duration</a>&gt;)</h4></section></summary><div class="docblock"><p>Set the keep-alive interval.</p>
<p>An idle socket with a keep-alive interval set will transmit a “keep-alive ACK” packet
every time it receives no communication during that interval. As a result, three things
may happen:</p>
<ul>
<li>The remote endpoint is fine and answers with an ACK packet.</li>
<li>The remote endpoint has rebooted and answers with an RST packet.</li>
<li>The remote endpoint has crashed and does not answer.</li>
</ul>
<p>The keep-alive functionality together with the timeout functionality allows to react
to these error conditions.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.hop_limit" class="method"><h4 class="code-header">pub fn <a href="#method.hop_limit" class="fn">hop_limit</a>(&amp;self) -&gt; Option&lt;u8&gt;</h4></section></summary><div class="docblock"><p>Return the time-to-live (IPv4) or hop limit (IPv6) value used in outgoing packets.</p>
<p>See also the <a href="#method.set_hop_limit">set_hop_limit</a> method</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_hop_limit" class="method"><h4 class="code-header">pub fn <a href="#method.set_hop_limit" class="fn">set_hop_limit</a>(&amp;mut self, hop_limit: Option&lt;u8&gt;)</h4></section></summary><div class="docblock"><p>Set the time-to-live (IPv4) or hop limit (IPv6) value used in outgoing packets.</p>
<p>A socket without an explicitly set hop limit value uses the default <a href="https://www.iana.org/assignments/ip-parameters/ip-parameters.xhtml">IANA recommended</a>
value (64).</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This function panics if a hop limit value of 0 is given. See <a href="https://tools.ietf.org/html/rfc1122#section-3.2.1.7">RFC 1122 § 3.2.1.7</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.listen_endpoint" class="method"><h4 class="code-header">pub fn <a href="#method.listen_endpoint" class="fn">listen_endpoint</a>(&amp;self) -&gt; ListenEndpoint</h4></section></summary><div class="docblock"><p>Return the listen endpoint</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.local_endpoint" class="method"><h4 class="code-header">pub fn <a href="#method.local_endpoint" class="fn">local_endpoint</a>(&amp;self) -&gt; Option&lt;<a class="struct" href="../wire/struct.IpEndpoint.html" title="struct aster_bigtcp::wire::IpEndpoint">Endpoint</a>&gt;</h4></section></summary><div class="docblock"><p>Return the local endpoint, or None if not connected.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remote_endpoint" class="method"><h4 class="code-header">pub fn <a href="#method.remote_endpoint" class="fn">remote_endpoint</a>(&amp;self) -&gt; Option&lt;<a class="struct" href="../wire/struct.IpEndpoint.html" title="struct aster_bigtcp::wire::IpEndpoint">Endpoint</a>&gt;</h4></section></summary><div class="docblock"><p>Return the remote endpoint, or None if not connected.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.state" class="method"><h4 class="code-header">pub fn <a href="#method.state" class="fn">state</a>(&amp;self) -&gt; State</h4></section></summary><div class="docblock"><p>Return the connection state, in terms of the TCP state machine.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.listen" class="method"><h4 class="code-header">pub fn <a href="#method.listen" class="fn">listen</a>&lt;T&gt;(&amp;mut self, local_endpoint: T) -&gt; Result&lt;(), ListenError&gt;<div class="where">where
    T: Into&lt;ListenEndpoint&gt;,</div></h4></section></summary><div class="docblock"><p>Start listening on the given endpoint.</p>
<p>This function returns <code>Err(Error::InvalidState)</code> if the socket was already open
(see <a href="#method.is_open">is_open</a>), and <code>Err(Error::Unaddressable)</code>
if the port in the given endpoint is zero.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.connect" class="method"><h4 class="code-header">pub fn <a href="#method.connect" class="fn">connect</a>&lt;T, U&gt;(
    &amp;mut self,
    cx: &amp;mut InterfaceInner,
    remote_endpoint: T,
    local_endpoint: U,
) -&gt; Result&lt;(), ConnectError&gt;<div class="where">where
    T: Into&lt;<a class="struct" href="../wire/struct.IpEndpoint.html" title="struct aster_bigtcp::wire::IpEndpoint">Endpoint</a>&gt;,
    U: Into&lt;ListenEndpoint&gt;,</div></h4></section></summary><div class="docblock"><p>Connect to a given endpoint.</p>
<p>The local port must be provided explicitly. Assuming <code>fn get_ephemeral_port() -&gt; u16</code>
allocates a port between 49152 and 65535, a connection may be established as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>socket.connect(
    iface.context(),
    (IpAddress::v4(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="number">80</span>),
    get_ephemeral_port()
).unwrap();</code></pre></div>
<p>The local address may optionally be provided.</p>
<p>This function returns an error if the socket was open; see <a href="#method.is_open">is_open</a>.
It also returns an error if the local or remote port is zero, or if the remote address
is unspecified.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.close" class="method"><h4 class="code-header">pub fn <a href="#method.close" class="fn">close</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Close the transmit half of the full-duplex connection.</p>
<p>Note that there is no corresponding function for the receive half of the full-duplex
connection; only the remote end can close it. If you no longer wish to receive any
data and would like to reuse the socket right away, use <a href="#method.abort">abort</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.abort" class="method"><h4 class="code-header">pub fn <a href="#method.abort" class="fn">abort</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Aborts the connection, if any.</p>
<p>This function instantly closes the socket. One reset packet will be sent to the remote
endpoint.</p>
<p>In terms of the TCP state machine, the socket may be in any state and is moved to
the <code>CLOSED</code> state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_listening" class="method"><h4 class="code-header">pub fn <a href="#method.is_listening" class="fn">is_listening</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Return whether the socket is passively listening for incoming connections.</p>
<p>In terms of the TCP state machine, the socket must be in the <code>LISTEN</code> state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_open" class="method"><h4 class="code-header">pub fn <a href="#method.is_open" class="fn">is_open</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Return whether the socket is open.</p>
<p>This function returns true if the socket will process incoming or dispatch outgoing
packets. Note that this does not mean that it is possible to send or receive data through
the socket; for that, use <a href="#method.can_send">can_send</a> or <a href="#method.can_recv">can_recv</a>.</p>
<p>In terms of the TCP state machine, the socket must not be in the <code>CLOSED</code>
or <code>TIME-WAIT</code> states.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_active" class="method"><h4 class="code-header">pub fn <a href="#method.is_active" class="fn">is_active</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Return whether a connection is active.</p>
<p>This function returns true if the socket is actively exchanging packets with
a remote endpoint. Note that this does not mean that it is possible to send or receive
data through the socket; for that, use <a href="#method.can_send">can_send</a> or
<a href="#method.can_recv">can_recv</a>.</p>
<p>If a connection is established, <a href="#method.close">abort</a> will send a reset to
the remote endpoint.</p>
<p>In terms of the TCP state machine, the socket must not be in the <code>CLOSED</code>, <code>TIME-WAIT</code>,
or <code>LISTEN</code> state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.may_send" class="method"><h4 class="code-header">pub fn <a href="#method.may_send" class="fn">may_send</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Return whether the transmit half of the full-duplex connection is open.</p>
<p>This function returns true if it’s possible to send data and have it arrive
to the remote endpoint. However, it does not make any guarantees about the state
of the transmit buffer, and even if it returns true, <a href="#method.send">send</a> may
not be able to enqueue any octets.</p>
<p>In terms of the TCP state machine, the socket must be in the <code>ESTABLISHED</code> or
<code>CLOSE-WAIT</code> state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.may_recv" class="method"><h4 class="code-header">pub fn <a href="#method.may_recv" class="fn">may_recv</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Return whether the receive half of the full-duplex connection is open.</p>
<p>This function returns true if it’s possible to receive data from the remote endpoint.
It will return true while there is data in the receive buffer, and if there isn’t,
as long as the remote endpoint has not closed the connection.</p>
<p>In terms of the TCP state machine, the socket must be in the <code>ESTABLISHED</code>,
<code>FIN-WAIT-1</code>, or <code>FIN-WAIT-2</code> state, or have data in the receive buffer instead.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.can_send" class="method"><h4 class="code-header">pub fn <a href="#method.can_send" class="fn">can_send</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Check whether the transmit half of the full-duplex connection is open
(see <a href="#method.may_send">may_send</a>), and the transmit buffer is not full.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.recv_capacity" class="method"><h4 class="code-header">pub fn <a href="#method.recv_capacity" class="fn">recv_capacity</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>Return the maximum number of bytes inside the recv buffer.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.send_capacity" class="method"><h4 class="code-header">pub fn <a href="#method.send_capacity" class="fn">send_capacity</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>Return the maximum number of bytes inside the transmit buffer.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.can_recv" class="method"><h4 class="code-header">pub fn <a href="#method.can_recv" class="fn">can_recv</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Check whether the receive half of the full-duplex connection buffer is open
(see <a href="#method.may_recv">may_recv</a>), and the receive buffer is not empty.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.send" class="method"><h4 class="code-header">pub fn <a href="#method.send" class="fn">send</a>&lt;'b, F, R&gt;(&amp;'b mut self, f: F) -&gt; Result&lt;R, SendError&gt;<div class="where">where
    F: FnOnce(&amp;'b mut [u8]) -&gt; (usize, R),</div></h4></section></summary><div class="docblock"><p>Call <code>f</code> with the largest contiguous slice of octets in the transmit buffer,
and enqueue the amount of elements returned by <code>f</code>.</p>
<p>This function returns <code>Err(Error::Illegal)</code> if the transmit half of
the connection is not open; see <a href="#method.may_send">may_send</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.send_slice" class="method"><h4 class="code-header">pub fn <a href="#method.send_slice" class="fn">send_slice</a>(&amp;mut self, data: &amp;[u8]) -&gt; Result&lt;usize, SendError&gt;</h4></section></summary><div class="docblock"><p>Enqueue a sequence of octets to be sent, and fill it from a slice.</p>
<p>This function returns the amount of octets actually enqueued, which is limited
by the amount of free space in the transmit buffer; down to zero.</p>
<p>See also <a href="#method.send">send</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.recv" class="method"><h4 class="code-header">pub fn <a href="#method.recv" class="fn">recv</a>&lt;'b, F, R&gt;(&amp;'b mut self, f: F) -&gt; Result&lt;R, RecvError&gt;<div class="where">where
    F: FnOnce(&amp;'b mut [u8]) -&gt; (usize, R),</div></h4></section></summary><div class="docblock"><p>Call <code>f</code> with the largest contiguous slice of octets in the receive buffer,
and dequeue the amount of elements returned by <code>f</code>.</p>
<p>This function errors if the receive half of the connection is not open.</p>
<p>If the receive half has been gracefully closed (with a FIN packet), <code>Err(Error::Finished)</code>
is returned. In this case, the previously received data is guaranteed to be complete.</p>
<p>In all other cases, <code>Err(Error::Illegal)</code> is returned and previously received data (if any)
may be incomplete (truncated).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.recv_slice" class="method"><h4 class="code-header">pub fn <a href="#method.recv_slice" class="fn">recv_slice</a>(&amp;mut self, data: &amp;mut [u8]) -&gt; Result&lt;usize, RecvError&gt;</h4></section></summary><div class="docblock"><p>Dequeue a sequence of received octets, and fill a slice from it.</p>
<p>This function returns the amount of octets actually dequeued, which is limited
by the amount of occupied space in the receive buffer; down to zero.</p>
<p>See also <a href="#method.recv">recv</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek" class="method"><h4 class="code-header">pub fn <a href="#method.peek" class="fn">peek</a>(&amp;mut self, size: usize) -&gt; Result&lt;&amp;[u8], RecvError&gt;</h4></section></summary><div class="docblock"><p>Peek at a sequence of received octets without removing them from
the receive buffer, and return a pointer to it.</p>
<p>This function otherwise behaves identically to <a href="#method.recv">recv</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_slice" class="method"><h4 class="code-header">pub fn <a href="#method.peek_slice" class="fn">peek_slice</a>(&amp;mut self, data: &amp;mut [u8]) -&gt; Result&lt;usize, RecvError&gt;</h4></section></summary><div class="docblock"><p>Peek at a sequence of received octets without removing them from
the receive buffer, and fill a slice from it.</p>
<p>This function otherwise behaves identically to <a href="#method.recv_slice">recv_slice</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.send_queue" class="method"><h4 class="code-header">pub fn <a href="#method.send_queue" class="fn">send_queue</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>Return the amount of octets queued in the transmit buffer.</p>
<p>Note that the Berkeley sockets interface does not have an equivalent of this API.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.recv_queue" class="method"><h4 class="code-header">pub fn <a href="#method.recv_queue" class="fn">recv_queue</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>Return the amount of octets queued in the receive buffer. This value can be larger than
the slice read by the next <code>recv</code> or <code>peek</code> call because it includes all queued octets,
and not only the octets that may be returned as a contiguous slice.</p>
<p>Note that the Berkeley sockets interface does not have an equivalent of this API.</p>
</div></details><section id="method.accepts" class="method"><h4 class="code-header">pub fn <a href="#method.accepts" class="fn">accepts</a>(
    &amp;self,
    _cx: &amp;mut InterfaceInner,
    ip_repr: &amp;Repr,
    repr: &amp;Repr&lt;'_&gt;,
) -&gt; bool</h4></section><section id="method.process" class="method"><h4 class="code-header">pub fn <a href="#method.process" class="fn">process</a>(
    &amp;mut self,
    cx: &amp;mut InterfaceInner,
    ip_repr: &amp;Repr,
    repr: &amp;Repr&lt;'_&gt;,
) -&gt; Option&lt;(Repr, Repr&lt;'static&gt;)&gt;</h4></section><section id="method.dispatch" class="method"><h4 class="code-header">pub fn <a href="#method.dispatch" class="fn">dispatch</a>&lt;F, E&gt;(
    &amp;mut self,
    cx: &amp;mut InterfaceInner,
    emit: F,
) -&gt; Result&lt;(), E&gt;<div class="where">where
    F: FnOnce(&amp;mut InterfaceInner, (Repr, Repr&lt;'_&gt;)) -&gt; Result&lt;(), E&gt;,</div></h4></section><section id="method.poll_at" class="method"><h4 class="code-header">pub fn <a href="#method.poll_at" class="fn">poll_at</a>(&amp;self, cx: &amp;mut InterfaceInner) -&gt; PollAt</h4></section></div></details><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Deref-for-RawTcpSocketExt%3CE%3E" class="impl"><a class="src rightside" href="../../src/aster_bigtcp/socket/bound/tcp_conn.rs.html#53-59">Source</a><a href="#impl-Deref-for-RawTcpSocketExt%3CE%3E" class="anchor">§</a><h3 class="code-header">impl&lt;E: <a class="trait" href="../ext/trait.Ext.html" title="trait aster_bigtcp::ext::Ext">Ext</a>&gt; Deref for <a class="struct" href="struct.RawTcpSocketExt.html" title="struct aster_bigtcp::socket::RawTcpSocketExt">RawTcpSocketExt</a>&lt;E&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a class="src rightside" href="../../src/aster_bigtcp/socket/bound/tcp_conn.rs.html#54">Source</a><a href="#associatedtype.Target" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Target</a> = Socket&lt;'static&gt;</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a class="src rightside" href="../../src/aster_bigtcp/socket/bound/tcp_conn.rs.html#56-58">Source</a><a href="#method.deref" class="anchor">§</a><h4 class="code-header">fn <a class="fn">deref</a>(&amp;self) -&gt; &amp;Self::Target</h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DerefMut-for-RawTcpSocketExt%3CE%3E" class="impl"><a class="src rightside" href="../../src/aster_bigtcp/socket/bound/tcp_conn.rs.html#61-65">Source</a><a href="#impl-DerefMut-for-RawTcpSocketExt%3CE%3E" class="anchor">§</a><h3 class="code-header">impl&lt;E: <a class="trait" href="../ext/trait.Ext.html" title="trait aster_bigtcp::ext::Ext">Ext</a>&gt; DerefMut for <a class="struct" href="struct.RawTcpSocketExt.html" title="struct aster_bigtcp::socket::RawTcpSocketExt">RawTcpSocketExt</a>&lt;E&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a class="src rightside" href="../../src/aster_bigtcp/socket/bound/tcp_conn.rs.html#62-64">Source</a><a href="#method.deref_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">deref_mut</a>(&amp;mut self) -&gt; &amp;mut Self::Target</h4></section></summary><div class='docblock'>Mutably dereferences the value.</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-RawTcpSocketExt%3CE%3E" class="impl"><a href="#impl-Freeze-for-RawTcpSocketExt%3CE%3E" class="anchor">§</a><h3 class="code-header">impl&lt;E&gt; Freeze for <a class="struct" href="struct.RawTcpSocketExt.html" title="struct aster_bigtcp::socket::RawTcpSocketExt">RawTcpSocketExt</a>&lt;E&gt;</h3></section><section id="impl-RefUnwindSafe-for-RawTcpSocketExt%3CE%3E" class="impl"><a href="#impl-RefUnwindSafe-for-RawTcpSocketExt%3CE%3E" class="anchor">§</a><h3 class="code-header">impl&lt;E&gt; !RefUnwindSafe for <a class="struct" href="struct.RawTcpSocketExt.html" title="struct aster_bigtcp::socket::RawTcpSocketExt">RawTcpSocketExt</a>&lt;E&gt;</h3></section><section id="impl-Send-for-RawTcpSocketExt%3CE%3E" class="impl"><a href="#impl-Send-for-RawTcpSocketExt%3CE%3E" class="anchor">§</a><h3 class="code-header">impl&lt;E&gt; Send for <a class="struct" href="struct.RawTcpSocketExt.html" title="struct aster_bigtcp::socket::RawTcpSocketExt">RawTcpSocketExt</a>&lt;E&gt;</h3></section><section id="impl-Sync-for-RawTcpSocketExt%3CE%3E" class="impl"><a href="#impl-Sync-for-RawTcpSocketExt%3CE%3E" class="anchor">§</a><h3 class="code-header">impl&lt;E&gt; Sync for <a class="struct" href="struct.RawTcpSocketExt.html" title="struct aster_bigtcp::socket::RawTcpSocketExt">RawTcpSocketExt</a>&lt;E&gt;</h3></section><section id="impl-Unpin-for-RawTcpSocketExt%3CE%3E" class="impl"><a href="#impl-Unpin-for-RawTcpSocketExt%3CE%3E" class="anchor">§</a><h3 class="code-header">impl&lt;E&gt; Unpin for <a class="struct" href="struct.RawTcpSocketExt.html" title="struct aster_bigtcp::socket::RawTcpSocketExt">RawTcpSocketExt</a>&lt;E&gt;</h3></section><section id="impl-UnwindSafe-for-RawTcpSocketExt%3CE%3E" class="impl"><a href="#impl-UnwindSafe-for-RawTcpSocketExt%3CE%3E" class="anchor">§</a><h3 class="code-header">impl&lt;E&gt; !UnwindSafe for <a class="struct" href="struct.RawTcpSocketExt.html" title="struct aster_bigtcp::socket::RawTcpSocketExt">RawTcpSocketExt</a>&lt;E&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Conv-for-T" class="impl"><a href="#impl-Conv-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Conv for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.conv" class="method trait-impl"><a href="#method.conv" class="anchor">§</a><h4 class="code-header">fn <a class="fn">conv</a>&lt;T&gt;(self) -&gt; T<div class="where">where
    Self: Into&lt;T&gt;,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into <code>T</code> using <code>Into&lt;T&gt;</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-FmtForward-for-T" class="impl"><a href="#impl-FmtForward-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; FmtForward for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt_binary" class="method trait-impl"><a href="#method.fmt_binary" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_binary</a>(self) -&gt; FmtBinary&lt;Self&gt;<div class="where">where
    Self: Binary,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Binary</code> implementation when <code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_display" class="method trait-impl"><a href="#method.fmt_display" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_display</a>(self) -&gt; FmtDisplay&lt;Self&gt;<div class="where">where
    Self: Display,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Display</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_lower_exp" class="method trait-impl"><a href="#method.fmt_lower_exp" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_lower_exp</a>(self) -&gt; FmtLowerExp&lt;Self&gt;<div class="where">where
    Self: LowerExp,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>LowerExp</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_lower_hex" class="method trait-impl"><a href="#method.fmt_lower_hex" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_lower_hex</a>(self) -&gt; FmtLowerHex&lt;Self&gt;<div class="where">where
    Self: LowerHex,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>LowerHex</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_octal" class="method trait-impl"><a href="#method.fmt_octal" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_octal</a>(self) -&gt; FmtOctal&lt;Self&gt;<div class="where">where
    Self: Octal,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Octal</code> implementation when <code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_pointer" class="method trait-impl"><a href="#method.fmt_pointer" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_pointer</a>(self) -&gt; FmtPointer&lt;Self&gt;<div class="where">where
    Self: Pointer,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>Pointer</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_upper_exp" class="method trait-impl"><a href="#method.fmt_upper_exp" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_upper_exp</a>(self) -&gt; FmtUpperExp&lt;Self&gt;<div class="where">where
    Self: UpperExp,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>UpperExp</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_upper_hex" class="method trait-impl"><a href="#method.fmt_upper_hex" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_upper_hex</a>(self) -&gt; FmtUpperHex&lt;Self&gt;<div class="where">where
    Self: UpperHex,</div></h4></section></summary><div class='docblock'>Causes <code>self</code> to use its <code>UpperHex</code> implementation when
<code>Debug</code>-formatted.</div></details><details class="toggle method-toggle" open><summary><section id="method.fmt_list" class="method trait-impl"><a href="#method.fmt_list" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt_list</a>(self) -&gt; FmtList&lt;Self&gt;<div class="where">where
    &amp;'a Self: for&lt;'a&gt; IntoIterator,</div></h4></section></summary><div class='docblock'>Formats each item in a sequence. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pipe-for-T" class="impl"><a href="#impl-Pipe-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Pipe for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.pipe" class="method trait-impl"><a href="#method.pipe" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe</a>&lt;R&gt;(self, func: impl FnOnce(Self) -&gt; R) -&gt; R<div class="where">where
    Self: Sized,</div></h4></section></summary><div class='docblock'>Pipes by value. This is generally the method you want to use. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_ref" class="method trait-impl"><a href="#method.pipe_ref" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_ref</a>&lt;'a, R&gt;(&amp;'a self, func: impl FnOnce(&amp;'a Self) -&gt; R) -&gt; R<div class="where">where
    R: 'a,</div></h4></section></summary><div class='docblock'>Borrows <code>self</code> and passes that borrow into the pipe function. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_ref_mut" class="method trait-impl"><a href="#method.pipe_ref_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_ref_mut</a>&lt;'a, R&gt;(&amp;'a mut self, func: impl FnOnce(&amp;'a mut Self) -&gt; R) -&gt; R<div class="where">where
    R: 'a,</div></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code> and passes that borrow into the pipe function. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_borrow" class="method trait-impl"><a href="#method.pipe_borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_borrow</a>&lt;'a, B, R&gt;(&amp;'a self, func: impl FnOnce(&amp;'a B) -&gt; R) -&gt; R<div class="where">where
    Self: Borrow&lt;B&gt;,
    B: 'a + ?Sized,
    R: 'a,</div></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.borrow()</code> into the pipe function. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_borrow_mut" class="method trait-impl"><a href="#method.pipe_borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_borrow_mut</a>&lt;'a, B, R&gt;(
    &amp;'a mut self,
    func: impl FnOnce(&amp;'a mut B) -&gt; R,
) -&gt; R<div class="where">where
    Self: BorrowMut&lt;B&gt;,
    B: 'a + ?Sized,
    R: 'a,</div></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.borrow_mut()</code> into the pipe
function. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_as_ref" class="method trait-impl"><a href="#method.pipe_as_ref" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_as_ref</a>&lt;'a, U, R&gt;(&amp;'a self, func: impl FnOnce(&amp;'a U) -&gt; R) -&gt; R<div class="where">where
    Self: AsRef&lt;U&gt;,
    U: 'a + ?Sized,
    R: 'a,</div></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.as_ref()</code> into the pipe function.</div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_as_mut" class="method trait-impl"><a href="#method.pipe_as_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_as_mut</a>&lt;'a, U, R&gt;(&amp;'a mut self, func: impl FnOnce(&amp;'a mut U) -&gt; R) -&gt; R<div class="where">where
    Self: AsMut&lt;U&gt;,
    U: 'a + ?Sized,
    R: 'a,</div></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.as_mut()</code> into the pipe
function.</div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_deref" class="method trait-impl"><a href="#method.pipe_deref" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_deref</a>&lt;'a, T, R&gt;(&amp;'a self, func: impl FnOnce(&amp;'a T) -&gt; R) -&gt; R<div class="where">where
    Self: Deref&lt;Target = T&gt;,
    T: 'a + ?Sized,
    R: 'a,</div></h4></section></summary><div class='docblock'>Borrows <code>self</code>, then passes <code>self.deref()</code> into the pipe function.</div></details><details class="toggle method-toggle" open><summary><section id="method.pipe_deref_mut" class="method trait-impl"><a href="#method.pipe_deref_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">pipe_deref_mut</a>&lt;'a, T, R&gt;(
    &amp;'a mut self,
    func: impl FnOnce(&amp;'a mut T) -&gt; R,
) -&gt; R<div class="where">where
    Self: DerefMut&lt;Target = T&gt; + Deref,
    T: 'a + ?Sized,
    R: 'a,</div></h4></section></summary><div class='docblock'>Mutably borrows <code>self</code>, then passes <code>self.deref_mut()</code> into the pipe
function.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pointee-for-T" class="impl"><a href="#impl-Pointee-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Pointee for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Metadata" class="associatedtype trait-impl"><a href="#associatedtype.Metadata" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Metadata</a> = ()</h4></section></summary><div class='docblock'>The metadata type for pointers and references to this type.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Receiver-for-P" class="impl"><a href="#impl-Receiver-for-P" class="anchor">§</a><h3 class="code-header">impl&lt;P, T&gt; Receiver for P<div class="where">where
    P: Deref&lt;Target = T&gt; + ?Sized,
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target-1" class="associatedtype trait-impl"><a href="#associatedtype.Target-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Target</a> = T</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>arbitrary_self_types</code>)</span></div></span><div class='docblock'>The target type on which the method may be called.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-SameAs%3CT%3E-for-T" class="impl"><a href="#impl-SameAs%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; SameAs&lt;T&gt; for T</h3></section></summary><div class="impl-items"><section id="associatedtype.Output" class="associatedtype trait-impl"><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Output</a> = True</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Tap-for-T" class="impl"><a href="#impl-Tap-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Tap for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.tap" class="method trait-impl"><a href="#method.tap" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap</a>(self, func: impl FnOnce(&amp;Self)) -&gt; Self</h4></section></summary><div class='docblock'>Immutable access to a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_mut" class="method trait-impl"><a href="#method.tap_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_mut</a>(self, func: impl FnOnce(&amp;mut Self)) -&gt; Self</h4></section></summary><div class='docblock'>Mutable access to a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow" class="method trait-impl"><a href="#method.tap_borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_borrow</a>&lt;B&gt;(self, func: impl FnOnce(&amp;B)) -&gt; Self<div class="where">where
    Self: Borrow&lt;B&gt;,
    B: ?Sized,</div></h4></section></summary><div class='docblock'>Immutable access to the <code>Borrow&lt;B&gt;</code> of a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow_mut" class="method trait-impl"><a href="#method.tap_borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_borrow_mut</a>&lt;B&gt;(self, func: impl FnOnce(&amp;mut B)) -&gt; Self<div class="where">where
    Self: BorrowMut&lt;B&gt;,
    B: ?Sized,</div></h4></section></summary><div class='docblock'>Mutable access to the <code>BorrowMut&lt;B&gt;</code> of a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref" class="method trait-impl"><a href="#method.tap_ref" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_ref</a>&lt;R&gt;(self, func: impl FnOnce(&amp;R)) -&gt; Self<div class="where">where
    Self: AsRef&lt;R&gt;,
    R: ?Sized,</div></h4></section></summary><div class='docblock'>Immutable access to the <code>AsRef&lt;R&gt;</code> view of a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref_mut" class="method trait-impl"><a href="#method.tap_ref_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_ref_mut</a>&lt;R&gt;(self, func: impl FnOnce(&amp;mut R)) -&gt; Self<div class="where">where
    Self: AsMut&lt;R&gt;,
    R: ?Sized,</div></h4></section></summary><div class='docblock'>Mutable access to the <code>AsMut&lt;R&gt;</code> view of a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref" class="method trait-impl"><a href="#method.tap_deref" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_deref</a>&lt;T&gt;(self, func: impl FnOnce(&amp;T)) -&gt; Self<div class="where">where
    Self: Deref&lt;Target = T&gt;,
    T: ?Sized,</div></h4></section></summary><div class='docblock'>Immutable access to the <code>Deref::Target</code> of a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref_mut" class="method trait-impl"><a href="#method.tap_deref_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_deref_mut</a>&lt;T&gt;(self, func: impl FnOnce(&amp;mut T)) -&gt; Self<div class="where">where
    Self: DerefMut&lt;Target = T&gt; + Deref,
    T: ?Sized,</div></h4></section></summary><div class='docblock'>Mutable access to the <code>Deref::Target</code> of a value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.tap_dbg" class="method trait-impl"><a href="#method.tap_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_dbg</a>(self, func: impl FnOnce(&amp;Self)) -&gt; Self</h4></section></summary><div class='docblock'>Calls <code>.tap()</code> only in debug builds, and is erased in release builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_mut_dbg" class="method trait-impl"><a href="#method.tap_mut_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_mut_dbg</a>(self, func: impl FnOnce(&amp;mut Self)) -&gt; Self</h4></section></summary><div class='docblock'>Calls <code>.tap_mut()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow_dbg" class="method trait-impl"><a href="#method.tap_borrow_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_borrow_dbg</a>&lt;B&gt;(self, func: impl FnOnce(&amp;B)) -&gt; Self<div class="where">where
    Self: Borrow&lt;B&gt;,
    B: ?Sized,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_borrow()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_borrow_mut_dbg" class="method trait-impl"><a href="#method.tap_borrow_mut_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_borrow_mut_dbg</a>&lt;B&gt;(self, func: impl FnOnce(&amp;mut B)) -&gt; Self<div class="where">where
    Self: BorrowMut&lt;B&gt;,
    B: ?Sized,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_borrow_mut()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref_dbg" class="method trait-impl"><a href="#method.tap_ref_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_ref_dbg</a>&lt;R&gt;(self, func: impl FnOnce(&amp;R)) -&gt; Self<div class="where">where
    Self: AsRef&lt;R&gt;,
    R: ?Sized,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_ref()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_ref_mut_dbg" class="method trait-impl"><a href="#method.tap_ref_mut_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_ref_mut_dbg</a>&lt;R&gt;(self, func: impl FnOnce(&amp;mut R)) -&gt; Self<div class="where">where
    Self: AsMut&lt;R&gt;,
    R: ?Sized,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_ref_mut()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref_dbg" class="method trait-impl"><a href="#method.tap_deref_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_deref_dbg</a>&lt;T&gt;(self, func: impl FnOnce(&amp;T)) -&gt; Self<div class="where">where
    Self: Deref&lt;Target = T&gt;,
    T: ?Sized,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_deref()</code> only in debug builds, and is erased in release
builds.</div></details><details class="toggle method-toggle" open><summary><section id="method.tap_deref_mut_dbg" class="method trait-impl"><a href="#method.tap_deref_mut_dbg" class="anchor">§</a><h4 class="code-header">fn <a class="fn">tap_deref_mut_dbg</a>&lt;T&gt;(self, func: impl FnOnce(&amp;mut T)) -&gt; Self<div class="where">where
    Self: DerefMut&lt;Target = T&gt; + Deref,
    T: ?Sized,</div></h4></section></summary><div class='docblock'>Calls <code>.tap_deref_mut()</code> only in debug builds, and is erased in release
builds.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryConv-for-T" class="impl"><a href="#impl-TryConv-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; TryConv for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_conv" class="method trait-impl"><a href="#method.try_conv" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_conv</a>&lt;T&gt;(self) -&gt; Result&lt;T, Self::Error&gt;<div class="where">where
    Self: TryInto&lt;T&gt;,</div></h4></section></summary><div class='docblock'>Attempts to convert <code>self</code> into <code>T</code> using <code>TryInto&lt;T&gt;</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>