<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Abstractions for reading and writing virtual memory (VM) objects."><title>ostd::mm::io - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-cf3c48c1.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="ostd" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (854f22563 2025-01-31)" data-channel="nightly" data-search-js="search-2d513d54.js" data-settings-js="settings-6dad6058.js" ><script src="../../../static.files/storage-302de22f.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-9b5d7e41.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../ostd/index.html">ostd</a><span class="version">0.16.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module io</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#safety" title="Safety">Safety</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In ostd::<wbr>mm</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">ostd</a>::<wbr><a href="../index.html">mm</a></div><h1>Module <span>io</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/ostd/mm/io.rs.html#3-1092">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Abstractions for reading and writing virtual memory (VM) objects.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">ยง</a>Safety</h2>
<p>The core virtual memory (VM) access APIs provided by this module are <a href="struct.VmReader.html" title="struct ostd::mm::io::VmReader"><code>VmReader</code></a> and
<a href="struct.VmWriter.html" title="struct ostd::mm::io::VmWriter"><code>VmWriter</code></a>, which allow for writing to or reading from a region of memory <em>safely</em>.
<code>VmReader</code> and <code>VmWriter</code> objects can be constructed from memory regions of either typed memory
(e.g., <code>&amp;[u8]</code>) or untyped memory (e.g, <a href="../frame/untyped/type.UFrame.html" title="type ostd::mm::frame::untyped::UFrame"><code>UFrame</code></a>). Behind the scene, <code>VmReader</code> and <code>VmWriter</code>
must be constructed via their <a href="struct.VmReader.html#method.from_user_space" title="associated function ostd::mm::io::VmReader::from_user_space"><code>from_user_space</code></a> and <a href="struct.VmReader.html#method.from_kernel_space" title="associated function ostd::mm::io::VmReader::from_kernel_space"><code>from_kernel_space</code></a> methods, whose
safety depends on whether the given memory regions are <em>valid</em> or not.</p>
<p>Here is a list of conditions for memory regions to be considered valid:</p>
<ul>
<li>
<p>The memory region as a whole must be either typed or untyped memory, not both typed and
untyped.</p>
</li>
<li>
<p>If the memory region is typed, we require that:</p>
<ul>
<li>the <a href="core::ptr#safety">validity requirements</a> from the official Rust documentation must be met, and</li>
<li>the type of the memory region (which must exist since the memory is typed) must be
plain-old-data, so that the writer can fill it with arbitrary data safely.</li>
</ul>
</li>
</ul>
<ul>
<li>If the memory region is untyped, we require that:
<ul>
<li>the underlying pages must remain alive while the validity requirements are in effect, and</li>
<li>the kernel must access the memory region using only the APIs provided in this module, but
external accesses from hardware devices or user programs do not count.</li>
</ul>
</li>
</ul>
<p>We have the last requirement for untyped memory to be valid because the safety interaction with
other ways to access the memory region (e.g., atomic/volatile memory loads/stores) is not
currently specified. Tis may be relaxed in the future, if appropriate and necessary.</p>
<p>Note that data races on untyped memory are explicitly allowed (since pages can be mapped to
user space, making it impossible to avoid data races). However, they may produce erroneous
results, such as unexpected bytes being copied, but do not cause soundness problems.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.VmReader.html" title="struct ostd::mm::io::VmReader">VmReader</a></dt><dd><code>VmReader</code> is a reader for reading data from a contiguous range of memory.</dd><dt><a class="struct" href="struct.VmWriter.html" title="struct ostd::mm::io::VmWriter">VmWriter</a></dt><dd><code>VmWriter</code> is a writer for writing data to a contiguous range of memory.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Fallible.html" title="enum ostd::mm::io::Fallible">Fallible</a></dt><dd>A marker type used for <a href="struct.VmReader.html" title="struct ostd::mm::io::VmReader"><code>VmReader</code></a> and <a href="struct.VmWriter.html" title="struct ostd::mm::io::VmWriter"><code>VmWriter</code></a>,
representing whether reads or writes on the underlying memory region are fallible.</dd><dt><a class="enum" href="enum.Infallible.html" title="enum ostd::mm::io::Infallible">Infallible</a></dt><dd>A marker type used for <a href="struct.VmReader.html" title="struct ostd::mm::io::VmReader"><code>VmReader</code></a> and <a href="struct.VmWriter.html" title="struct ostd::mm::io::VmWriter"><code>VmWriter</code></a>,
representing whether reads or writes on the underlying memory region are infallible.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="trait" href="trait.FallibleVmRead.html" title="trait ostd::mm::io::FallibleVmRead">Fallible<wbr>VmRead</a></dt><dd>Fallible memory read from a <code>VmWriter</code>.</dd><dt><a class="trait" href="trait.FallibleVmWrite.html" title="trait ostd::mm::io::FallibleVmWrite">Fallible<wbr>VmWrite</a></dt><dd>Fallible memory write from a <code>VmReader</code>.</dd><dt><a class="trait" href="trait.PodAtomic.html" title="trait ostd::mm::io::PodAtomic">PodAtomic</a></dt><dd>A marker trait for POD types that can be read or written atomically.</dd><dt><a class="trait" href="trait.PodOnce.html" title="trait ostd::mm::io::PodOnce">PodOnce</a></dt><dd>A marker trait for POD types that can be read or written with one instruction.</dd><dt><a class="trait" href="trait.VmIo.html" title="trait ostd::mm::io::VmIo">VmIo</a></dt><dd>A trait that enables reading/writing data from/to a VM object,
e.g., <a href="../frame/segment/type.USegment.html" title="type ostd::mm::frame::segment::USegment"><code>USegment</code></a>, [<code>Vec&lt;UFrame&gt;</code>] and <a href="../frame/untyped/type.UFrame.html" title="type ostd::mm::frame::untyped::UFrame"><code>UFrame</code></a>.</dd><dt><a class="trait" href="trait.VmIoFill.html" title="trait ostd::mm::io::VmIoFill">VmIo<wbr>Fill</a></dt><dd>A trait that enables filling bytes (e.g., filling zeros) to a VM object.</dd><dt><a class="trait" href="trait.VmIoOnce.html" title="trait ostd::mm::io::VmIoOnce">VmIo<wbr>Once</a></dt><dd>A trait that enables reading/writing data from/to a VM object using one non-tearing memory
load/store.</dd></dl></section></div></main></body></html>