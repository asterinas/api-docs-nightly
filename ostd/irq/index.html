<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Handling of Interrupt ReQuests (IRQs)."><title>ostd::irq - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-cf3c48c1.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="ostd" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (854f22563 2025-01-31)" data-channel="nightly" data-search-js="search-2d513d54.js" data-settings-js="settings-6dad6058.js" ><script src="../../static.files/storage-302de22f.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-9b5d7e41.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../ostd/index.html">ostd</a><span class="version">0.16.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module irq</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#top-vs-bottom-half" title="Top vs bottom half">Top vs bottom half</a></li><li><a href="#nested-interrupts" title="Nested interrupts">Nested interrupts</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate ostd</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">ostd</a></div><h1>Module <span>irq</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/ostd/irq/mod.rs.html#3-101">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Handling of Interrupt ReQuests (IRQs).</p>
<h2 id="top-vs-bottom-half"><a class="doc-anchor" href="#top-vs-bottom-half">§</a>Top vs bottom half</h2>
<p>OSTD divides the handling of an IRQ into two parts:
<strong>top half</strong> and <strong>bottom half</strong>.</p>
<p>A driver can assign to a target device an IRQ line, <a href="struct.IrqLine.html" title="struct ostd::irq::IrqLine"><code>IrqLine</code></a>,
to which a callback function may be registered.
When an IRQ arrives at an IRQ line,
OSTD will invoke all the callbacks registered on the line,
with all local IRQs on the CPU disabled.
Thus, the <code>IrqLine</code> callbacks should be written as short as possible,
performing the most critical tasks.
This is the so-called top half of IRQ handling.</p>
<p>When the top half finishes,
OSTD continues on the handling of the IRQ with the bottom half.
The logic of the bottom half is specified
by a callback function registered via <a href="fn.register_bottom_half_handler_l1.html" title="fn ostd::irq::register_bottom_half_handler_l1"><code>register_bottom_half_handler_l1</code></a>
(or <a href="fn.register_bottom_half_handler_l2.html" title="fn ostd::irq::register_bottom_half_handler_l2"><code>register_bottom_half_handler_l2</code></a>, as we will see later).
The implementer of this callback function may re-enable local IRQs,
thus allowing the less critical tasks performed in the bottom half
to be preempted by the more critical ones done in the top half.</p>
<p>OSTD’s split of IRQ handling in top and bottom halves
closely resembles that of Linux,
but with a key difference:
OSTD itself does not hardcode any concrete mechanisms for the bottom-half,
e.g., Linux’s softirqs or tasklets.
OSTD’s APIs are flexible and powerful enough to
enable an OSTD-based kernel to implement such mechanisms itself.
This design helps contain the size and complexity of OSTD.</p>
<h2 id="nested-interrupts"><a class="doc-anchor" href="#nested-interrupts">§</a>Nested interrupts</h2>
<p>OSTD allows interrupts to be nested.
The top-half for handling nested interrupts are still done by <code>IrqLine</code> callbacks,
yet the bottom-half logic is done by a new callback
registered via <a href="fn.register_bottom_half_handler_l2.html" title="fn ostd::irq::register_bottom_half_handler_l2"><code>register_bottom_half_handler_l2</code></a>,
rather than <a href="fn.register_bottom_half_handler_l1.html" title="fn ostd::irq::register_bottom_half_handler_l1"><code>register_bottom_half_handler_l1</code></a>.</p>
<p>We introduce the concept of <strong>interrupt level</strong> to
mark the nesting depth of interrupts.
<a href="enum.InterruptLevel.html#method.current" title="associated function ostd::irq::InterruptLevel::current"><code>InterruptLevel::current</code></a> keeps track of the current nesting depth
on the CPU where the code is executing.
There are three interrupt levels:</p>
<ul>
<li>
<p><strong>Level 0 (Task Context):</strong>
Normal execution for a kernel or user task.
Code at this level can be preempted by a hardware interrupt.</p>
</li>
<li>
<p><strong>Level 1 (Interrupt Context):</strong>
Entered when an interrupt preempts task context code.
Interrupt handling callbacks that may be invoked at this level are:</p>
<ul>
<li>The top-half callbacks registered via <a href="struct.IrqLine.html" title="struct ostd::irq::IrqLine"><code>IrqLine</code></a>;</li>
<li>The bottom-half callback registered via <a href="fn.register_bottom_half_handler_l1.html" title="fn ostd::irq::register_bottom_half_handler_l1"><code>register_bottom_half_handler_l1</code></a>.</li>
</ul>
</li>
<li>
<p><strong>Level 2 (Nested Interrupt Context):</strong>
The maximum nesting level,
entered when a level 1 bottom-half callback
(registered via <code>register_bottom_half_handler_l1</code>) is interrupted.
<code>IrqLine</code> callbacks always have IRQ disabled;
thus, they can never be preempted.</p>
<p>Interrupt handling callbacks that may be invoked at this level are:</p>
<ul>
<li>The top-half callbacks registered via <a href="struct.IrqLine.html" title="struct ostd::irq::IrqLine"><code>IrqLine</code></a>;</li>
<li>The bottom-half callback registered via <a href="fn.register_bottom_half_handler_l2.html" title="fn ostd::irq::register_bottom_half_handler_l2"><code>register_bottom_half_handler_l2</code></a>
(not <a href="fn.register_bottom_half_handler_l1.html" title="fn ostd::irq::register_bottom_half_handler_l1"><code>register_bottom_half_handler_l1</code></a>).</li>
</ul>
<p>At this level, all local IRQs are disabled to prevent further nesting.</p>
</li>
</ul>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.DisabledLocalIrqGuard.html" title="struct ostd::irq::DisabledLocalIrqGuard">Disabled<wbr>Local<wbr>IrqGuard</a></dt><dd>A guard for disabled local IRQs.</dd><dt><a class="struct" href="struct.IrqLine.html" title="struct ostd::irq::IrqLine">IrqLine</a></dt><dd>An Interrupt ReQuest (IRQ) line.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.InterruptLevel.html" title="enum ostd::irq::InterruptLevel">Interrupt<wbr>Level</a></dt><dd>The current interrupt level on a CPU.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.disable_local.html" title="fn ostd::irq::disable_local">disable_<wbr>local</a></dt><dd>Disables all IRQs on the current CPU (i.e., locally).</dd><dt><a class="fn" href="fn.register_bottom_half_handler_l1.html" title="fn ostd::irq::register_bottom_half_handler_l1">register_<wbr>bottom_<wbr>half_<wbr>handler_<wbr>l1</a></dt><dd>Registers a bottom half callback to be executed at interrupt level 1.</dd><dt><a class="fn" href="fn.register_bottom_half_handler_l2.html" title="fn ostd::irq::register_bottom_half_handler_l2">register_<wbr>bottom_<wbr>half_<wbr>handler_<wbr>l2</a></dt><dd>Registers a bottom half callback to be executed at interrupt level 2.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.IrqCallbackFunction.html" title="type ostd::irq::IrqCallbackFunction">IrqCallback<wbr>Function</a></dt><dd>A type alias for the IRQ callback function.</dd></dl></section></div></main></body></html>