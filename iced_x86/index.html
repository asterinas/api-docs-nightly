<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="iced-x86 Latest version Documentation Minimum rustc version License"><title>iced_x86 - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-cf3c48c1.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="iced_x86" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (854f22563 2025-01-31)" data-channel="nightly" data-search-js="search-2d513d54.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-302de22f.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-9b5d7e41.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../iced_x86/index.html"><img src="https://raw.githubusercontent.com/icedland/iced/master/logo.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../iced_x86/index.html"><img src="https://raw.githubusercontent.com/icedland/iced/master/logo.png" alt="logo"></a><h2><a href="../iced_x86/index.html">iced_<wbr>x86</a><span class="version">1.21.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#usage" title="Usage">Usage</a></li><li><a href="#crate-feature-flags" title="Crate feature flags">Crate feature flags</a></li><li><a href="#how-tos" title="How-tos">How-tos</a></li><li><a href="#disassemble-decode-and-format-instructions" title="Disassemble (decode and format instructions)">Disassemble (decode and format instructions)</a></li><li><a href="#assemble-instructions" title="Assemble instructions">Assemble instructions</a></li><li><a href="#disassemble-with-a-symbol-resolver" title="Disassemble with a symbol resolver">Disassemble with a symbol resolver</a></li><li><a href="#disassemble-with-colorized-text" title="Disassemble with colorized text">Disassemble with colorized text</a></li><li><a href="#move-code-in-memory-eg-hook-a-function" title="Move code in memory (eg. hook a function)">Move code in memory (eg. hook a function)</a></li><li><a href="#get-instruction-info-eg-readwritten-regsmem-control-flow-info-etc" title="Get instruction info, eg. read/written regs/mem, control flow info, etc">Get instruction info, eg. read/written regs/mem, control flow info, etc</a></li><li><a href="#get-the-virtual-address-of-a-memory-operand" title="Get the virtual address of a memory operand">Get the virtual address of a memory operand</a></li><li><a href="#disassemble-olddeprecated-cpu-instructions" title="Disassemble old/deprecated CPU instructions">Disassemble old/deprecated CPU instructions</a></li><li><a href="#disassemble-as-fast-as-possible" title="Disassemble as fast as possible">Disassemble as fast as possible</a></li><li><a href="#create-and-encode-instructions" title="Create and encode instructions">Create and encode instructions</a></li><li><a href="#minimum-supported-rustc-version" title="Minimum supported `rustc` version">Minimum supported <code>rustc</code> version</a></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>iced_x86</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/iced_x86/lib.rs.html#4-185">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>iced-x86
<a href="https://crates.io/crates/iced-x86"><img src="https://img.shields.io/crates/v/iced-x86.svg" alt="Latest version" /></a>
<a href="https://docs.rs/iced-x86"><img src="https://docs.rs/iced-x86/badge.svg" alt="Documentation" /></a>
<a href="#minimum-supported-rustc-version"><img src="https://img.shields.io/badge/rustc-1.57.0+-blue.svg" alt="Minimum rustc version" /></a>
<img src="https://img.shields.io/crates/l/iced-x86.svg" alt="License" /></p>
<p>iced-x86 is a blazing fast and correct x86 (16/32/64-bit) instruction decoder, disassembler and assembler written in Rust.</p>
<ul>
<li>👍 Supports all Intel and AMD instructions</li>
<li>👍 Correct: All instructions are tested and iced has been tested against other disassemblers/assemblers (xed, gas, objdump, masm, dumpbin, nasm, ndisasm) and fuzzed</li>
<li>👍 100% Rust code</li>
<li>👍 The formatter supports masm, nasm, gas (AT&amp;T), Intel (XED) and there are many options to customize the output</li>
<li>👍 Blazing fast: Decodes &gt;250 MB/s and decode+format &gt;130 MB/s (<a href="https://github.com/icedland/disas-bench/tree/a865849deacfb6c33ee0e78f3a3ad7f4c82099f5#results">see here</a>)</li>
<li>👍 Small decoded instructions, only 40 bytes and the decoder doesn’t allocate any memory</li>
<li>👍 Create instructions with code assembler, eg. <code>asm.mov(eax, edx)</code></li>
<li>👍 The encoder can be used to re-encode decoded instructions at any address</li>
<li>👍 API to get instruction info, eg. read/written registers, memory and rflags bits; CPUID feature flag, control flow info, etc</li>
<li>👍 Supports <code>#![no_std]</code> and <code>WebAssembly</code></li>
<li>👍 Supports <code>rustc</code> <code>1.57.0</code> or later</li>
<li>👍 Few dependencies (<code>lazy_static</code>)</li>
<li>👍 License: MIT</li>
</ul>
<h3 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h3>
<p>Add this to your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
iced-x86 = &quot;1.21.0&quot;</code></pre></div>
<p>Or to customize which features to use:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.iced-x86]
version = &quot;1.21.0&quot;
default-features = false
# See below for all features
features = [&quot;std&quot;, &quot;decoder&quot;, &quot;masm&quot;]</code></pre></div><h3 id="crate-feature-flags"><a class="doc-anchor" href="#crate-feature-flags">§</a>Crate feature flags</h3>
<p>You can enable/disable these in your <code>Cargo.toml</code> file.</p>
<ul>
<li><code>decoder</code>: (👍 Enabled by default) Enables the decoder</li>
<li><code>encoder</code>: (👍 Enabled by default) Enables the encoder</li>
<li><code>block_encoder</code>: (👍 Enabled by default) Enables the <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.BlockEncoder.html"><code>BlockEncoder</code></a>. This feature enables <code>encoder</code></li>
<li><code>op_code_info</code>: (👍 Enabled by default) Enables getting instruction metadata (<a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.OpCodeInfo.html"><code>OpCodeInfo</code></a>). This feature enables <code>encoder</code></li>
<li><code>instr_info</code>: (👍 Enabled by default) Enables the instruction info code</li>
<li><code>gas</code>: (👍 Enabled by default) Enables the GNU Assembler (AT&amp;T) formatter</li>
<li><code>intel</code>: (👍 Enabled by default) Enables the Intel (XED) formatter</li>
<li><code>masm</code>: (👍 Enabled by default) Enables the masm formatter</li>
<li><code>nasm</code>: (👍 Enabled by default) Enables the nasm formatter</li>
<li><code>fast_fmt</code>: (👍 Enabled by default) Enables <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.SpecializedFormatter.html"><code>SpecializedFormatter&lt;TraitOptions&gt;</code></a> (and <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/type.FastFormatter.html"><code>FastFormatter</code></a>) (masm syntax) which is ~3.3x faster than the other formatters (the time includes decoding + formatting). Use it if formatting speed is more important than being able to re-assemble formatted instructions or if targeting wasm (this formatter uses less code).</li>
<li><code>code_asm</code>: Enables <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/code_asm/struct.CodeAssembler.html"><code>CodeAssembler</code></a> to allow easy creation of instructions, eg. <code>a.xor(ecx, dword_ptr(edx))</code> instead of using the more verbose <code>Instruction::with*()</code> methods.</li>
<li><code>serde</code>: Enables serialization support (<a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.Instruction.html"><code>Instruction</code></a>). Not guaranteed to work if different versions of iced was used to serialize and deserialize it.</li>
<li><code>std</code>: (👍 Enabled by default) Enables the <code>std</code> crate. <code>std</code> or <code>no_std</code> must be defined, but not both.</li>
<li><code>no_std</code>: Enables <code>#![no_std]</code>. <code>std</code> or <code>no_std</code> must be defined, but not both. This feature uses the <code>alloc</code> crate.</li>
<li><code>mvex</code>: Enables <code>MVEX</code> instructions (Knights Corner). You must also pass in <code>DecoderOptions::KNC</code> to the <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.Decoder.html"><code>Decoder</code></a> constructor.</li>
<li><code>exhaustive_enums</code>: Enables exhaustive enums, i.e., no enum has the <code>#[non_exhaustive]</code> attribute</li>
</ul>
<h3 id="how-tos"><a class="doc-anchor" href="#how-tos">§</a>How-tos</h3>
<ul>
<li><a href="#disassemble-decode-and-format-instructions">Disassemble (decode and format instructions)</a></li>
<li><a href="#assemble-instructions">Assemble instructions</a></li>
<li><a href="#disassemble-with-a-symbol-resolver">Disassemble with a symbol resolver</a></li>
<li><a href="#disassemble-with-colorized-text">Disassemble with colorized text</a></li>
<li><a href="#move-code-in-memory-eg-hook-a-function">Move code in memory (eg. hook a function)</a></li>
<li><a href="#get-instruction-info-eg-readwritten-regsmem-control-flow-info-etc">Get instruction info, eg. read/written regs/mem, control flow info, etc</a></li>
<li><a href="#get-the-virtual-address-of-a-memory-operand">Get the virtual address of a memory operand</a></li>
<li><a href="#disassemble-olddeprecated-cpu-instructions">Disassemble old/deprecated CPU instructions</a></li>
<li><a href="#disassemble-as-fast-as-possible">Disassemble as fast as possible</a></li>
<li><a href="#create-and-encode-instructions">Create and encode instructions</a></li>
</ul>
<h3 id="disassemble-decode-and-format-instructions"><a class="doc-anchor" href="#disassemble-decode-and-format-instructions">§</a>Disassemble (decode and format instructions)</h3>
<p>This example uses a <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.Decoder.html"><code>Decoder</code></a> and one of the <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/trait.Formatter.html"><code>Formatter</code></a>s to decode and format the code,
eg. <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.GasFormatter.html"><code>GasFormatter</code></a>, <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.IntelFormatter.html"><code>IntelFormatter</code></a>, <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.MasmFormatter.html"><code>MasmFormatter</code></a>, <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.NasmFormatter.html"><code>NasmFormatter</code></a>, <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.SpecializedFormatter.html"><code>SpecializedFormatter&lt;TraitOptions&gt;</code></a> (or <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/type.FastFormatter.html"><code>FastFormatter</code></a>).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>iced_x86::{Decoder, DecoderOptions, Formatter, Instruction, NasmFormatter};

<span class="comment">/*
This method produces the following output:
00007FFAC46ACDA4 48895C2410           mov       [rsp+10h],rbx
00007FFAC46ACDA9 4889742418           mov       [rsp+18h],rsi
00007FFAC46ACDAE 55                   push      rbp
00007FFAC46ACDAF 57                   push      rdi
00007FFAC46ACDB0 4156                 push      r14
00007FFAC46ACDB2 488DAC2400FFFFFF     lea       rbp,[rsp-100h]
00007FFAC46ACDBA 4881EC00020000       sub       rsp,200h
00007FFAC46ACDC1 488B0518570A00       mov       rax,[rel 7FFA`C475`24E0h]
00007FFAC46ACDC8 4833C4               xor       rax,rsp
00007FFAC46ACDCB 488985F0000000       mov       [rbp+0F0h],rax
00007FFAC46ACDD2 4C8B052F240A00       mov       r8,[rel 7FFA`C474`F208h]
00007FFAC46ACDD9 488D05787C0400       lea       rax,[rel 7FFA`C46F`4A58h]
00007FFAC46ACDE0 33FF                 xor       edi,edi
*/
</span><span class="attr">#[allow(dead_code)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>how_to_disassemble() {
    <span class="kw">let </span>bytes = EXAMPLE_CODE;
    <span class="kw">let </span><span class="kw-2">mut </span>decoder =
        Decoder::with_ip(EXAMPLE_CODE_BITNESS, bytes, EXAMPLE_CODE_RIP, DecoderOptions::NONE);

    <span class="comment">// Formatters: Masm*, Nasm*, Gas* (AT&amp;T) and Intel* (XED).
    // For fastest code, see `SpecializedFormatter` which is ~3.3x faster. Use it if formatting
    // speed is more important than being able to re-assemble formatted instructions.
    </span><span class="kw">let </span><span class="kw-2">mut </span>formatter = NasmFormatter::new();

    <span class="comment">// Change some options, there are many more
    </span>formatter.options_mut().set_digit_separator(<span class="string">"`"</span>);
    formatter.options_mut().set_first_operand_char_index(<span class="number">10</span>);

    <span class="comment">// String implements FormatterOutput
    </span><span class="kw">let </span><span class="kw-2">mut </span>output = String::new();

    <span class="comment">// Initialize this outside the loop because decode_out() writes to every field
    </span><span class="kw">let </span><span class="kw-2">mut </span>instruction = Instruction::default();

    <span class="comment">// The decoder also implements Iterator/IntoIterator so you could use a for loop:
    //      for instruction in &amp;mut decoder { /* ... */ }
    // or collect():
    //      let instructions: Vec&lt;_&gt; = decoder.into_iter().collect();
    // but can_decode()/decode_out() is a little faster:
    </span><span class="kw">while </span>decoder.can_decode() {
        <span class="comment">// There's also a decode() method that returns an instruction but that also
        // means it copies an instruction (40 bytes):
        //     instruction = decoder.decode();
        </span>decoder.decode_out(<span class="kw-2">&amp;mut </span>instruction);

        <span class="comment">// Format the instruction ("disassemble" it)
        </span>output.clear();
        formatter.format(<span class="kw-2">&amp;</span>instruction, <span class="kw-2">&amp;mut </span>output);

        <span class="comment">// Eg. "00007FFAC46ACDB2 488DAC2400FFFFFF     lea       rbp,[rsp-100h]"
        </span><span class="macro">print!</span>(<span class="string">"{:016X} "</span>, instruction.ip());
        <span class="kw">let </span>start_index = (instruction.ip() - EXAMPLE_CODE_RIP) <span class="kw">as </span>usize;
        <span class="kw">let </span>instr_bytes = <span class="kw-2">&amp;</span>bytes[start_index..start_index + instruction.len()];
        <span class="kw">for </span>b <span class="kw">in </span>instr_bytes.iter() {
            <span class="macro">print!</span>(<span class="string">"{:02X}"</span>, b);
        }
        <span class="kw">if </span>instr_bytes.len() &lt; HEXBYTES_COLUMN_BYTE_LENGTH {
            <span class="kw">for _ in </span><span class="number">0</span>..HEXBYTES_COLUMN_BYTE_LENGTH - instr_bytes.len() {
                <span class="macro">print!</span>(<span class="string">"  "</span>);
            }
        }
        <span class="macro">println!</span>(<span class="string">" {}"</span>, output);
    }
}

<span class="kw">const </span>HEXBYTES_COLUMN_BYTE_LENGTH: usize = <span class="number">10</span>;
<span class="kw">const </span>EXAMPLE_CODE_BITNESS: u32 = <span class="number">64</span>;
<span class="kw">const </span>EXAMPLE_CODE_RIP: u64 = <span class="number">0x0000_7FFA_C46A_CDA4</span>;
<span class="kw">static </span>EXAMPLE_CODE: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[
    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x5C</span>, <span class="number">0x24</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x74</span>, <span class="number">0x24</span>, <span class="number">0x18</span>, <span class="number">0x55</span>, <span class="number">0x57</span>, <span class="number">0x41</span>, <span class="number">0x56</span>, <span class="number">0x48</span>, <span class="number">0x8D</span>,
    <span class="number">0xAC</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x48</span>, <span class="number">0x81</span>, <span class="number">0xEC</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x05</span>,
    <span class="number">0x18</span>, <span class="number">0x57</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x33</span>, <span class="number">0xC4</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x85</span>, <span class="number">0xF0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>,
    <span class="number">0x05</span>, <span class="number">0x2F</span>, <span class="number">0x24</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8D</span>, <span class="number">0x05</span>, <span class="number">0x78</span>, <span class="number">0x7C</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x33</span>, <span class="number">0xFF</span>,
];</code></pre></div>
<h3 id="assemble-instructions"><a class="doc-anchor" href="#assemble-instructions">§</a>Assemble instructions</h3>
<p>This allows you to easily create instructions (eg. <code>a.xor(eax, ecx)?</code>) without having to use the more verbose <code>Instruction::with*()</code> functions.</p>
<p>This requires the <code>code_asm</code> feature to use (not enabled by default). Add it to your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.iced-x86]
version = &quot;1.21.0&quot;
features = [&quot;code_asm&quot;]</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>iced_x86::code_asm::<span class="kw-2">*</span>;

<span class="attr">#[allow(dead_code)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>how_to_use_code_assembler() -&gt; <span class="prelude-ty">Result</span>&lt;(), IcedError&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>a = CodeAssembler::new(<span class="number">64</span>)<span class="question-mark">?</span>;

    <span class="comment">// Anytime you add something to a register (or subtract from it), you create a
    // memory operand. You can also call word_ptr(), dword_bcst() etc to create memory
    // operands.
    </span><span class="kw">let _ </span>= rax; <span class="comment">// register
    </span><span class="kw">let _ </span>= rax + <span class="number">0</span>; <span class="comment">// memory with no size hint
    </span><span class="kw">let _ </span>= ptr(rax); <span class="comment">// memory with no size hint
    </span><span class="kw">let _ </span>= rax + rcx * <span class="number">4 </span>- <span class="number">123</span>; <span class="comment">// memory with no size hint
    // To create a memory operand with only a displacement or only a base register,
    // you can call one of the memory fns:
    </span><span class="kw">let _ </span>= qword_ptr(<span class="number">123</span>); <span class="comment">// memory with a qword size hint
    </span><span class="kw">let _ </span>= dword_bcst(rcx); <span class="comment">// memory (broadcast) with a dword size hint
    // To add a segment override, call the segment methods:
    </span><span class="kw">let _ </span>= ptr(rax).fs(); <span class="comment">// fs:[rax]

    // Each mnemonic is a method
    </span>a.push(rcx)<span class="question-mark">?</span>;
    <span class="comment">// There are a few exceptions where you must append `_&lt;opcount&gt;` to the mnemonic to
    // get the instruction you need:
    </span>a.ret()<span class="question-mark">?</span>;
    a.ret_1(<span class="number">123</span>)<span class="question-mark">?</span>;
    <span class="comment">// Use byte_ptr(), word_bcst(), etc to force the arg to a memory operand and to add a
    // size hint
    </span>a.xor(byte_ptr(rdx+r14<span class="kw-2">*</span><span class="number">4</span>+<span class="number">123</span>), <span class="number">0x10</span>)<span class="question-mark">?</span>;
    <span class="comment">// Prefixes are also methods
    </span>a.rep().stosd()<span class="question-mark">?</span>;
    <span class="comment">// Sometimes, you must add an integer suffix to help the compiler:
    </span>a.mov(rax, <span class="number">0x1234_5678_9ABC_DEF0u64</span>)<span class="question-mark">?</span>;

    <span class="comment">// Create labels that can be referenced by code
    </span><span class="kw">let </span><span class="kw-2">mut </span>loop_lbl1 = a.create_label();
    <span class="kw">let </span><span class="kw-2">mut </span>after_loop1 = a.create_label();
    a.mov(ecx, <span class="number">10</span>)<span class="question-mark">?</span>;
    a.set_label(<span class="kw-2">&amp;mut </span>loop_lbl1)<span class="question-mark">?</span>;
    <span class="comment">// If needed, a zero-bytes instruction can be used as a label but this is optional
    </span>a.zero_bytes()<span class="question-mark">?</span>;
    a.dec(ecx)<span class="question-mark">?</span>;
    a.jp(after_loop1)<span class="question-mark">?</span>;
    a.jne(loop_lbl1)<span class="question-mark">?</span>;
    a.set_label(<span class="kw-2">&amp;mut </span>after_loop1)<span class="question-mark">?</span>;

    <span class="comment">// It's possible to reference labels with RIP-relative addressing
    </span><span class="kw">let </span><span class="kw-2">mut </span>skip_data = a.create_label();
    <span class="kw">let </span><span class="kw-2">mut </span>data = a.create_label();
    a.jmp(skip_data)<span class="question-mark">?</span>;
    a.set_label(<span class="kw-2">&amp;mut </span>data)<span class="question-mark">?</span>;
    a.db(<span class="string">b"\x90\xCC\xF1\x90"</span>)<span class="question-mark">?</span>;
    a.set_label(<span class="kw-2">&amp;mut </span>skip_data)<span class="question-mark">?</span>;
    a.lea(rax, ptr(data))<span class="question-mark">?</span>;

    <span class="comment">// AVX512 opmasks, {z}, {sae}, {er} and broadcasting are also supported:
    </span>a.vsqrtps(zmm16.k2().z(), dword_bcst(rcx))<span class="question-mark">?</span>;
    a.vsqrtps(zmm1.k2().z(), zmm23.rd_sae())<span class="question-mark">?</span>;
    <span class="comment">// Sometimes, the encoder doesn't know if you want VEX or EVEX encoding.
    // You can force EVEX globally like so:
    </span>a.set_prefer_vex(<span class="bool-val">false</span>);
    a.vucomiss(xmm31, xmm15.sae())<span class="question-mark">?</span>;
    a.vucomiss(xmm31, ptr(rcx))<span class="question-mark">?</span>;
    <span class="comment">// or call vex()/evex() to override the encoding option:
    </span>a.evex().vucomiss(xmm31, xmm15.sae())<span class="question-mark">?</span>;
    a.vex().vucomiss(xmm15, xmm14)<span class="question-mark">?</span>;

    <span class="comment">// Encode all added instructions.
    // Use `assemble_options()` if you must get the address of a label
    </span><span class="kw">let </span>bytes = a.assemble(<span class="number">0x1234_5678</span>)<span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(bytes.len(), <span class="number">82</span>);
    <span class="comment">// If you don't want to encode them, you can get all instructions by calling
    // one of these methods:
    </span><span class="kw">let </span>instrs = a.instructions(); <span class="comment">// Get a reference to the internal vec
    </span><span class="macro">assert_eq!</span>(instrs.len(), <span class="number">19</span>);
    <span class="kw">let </span>instrs = a.take_instructions(); <span class="comment">// Take ownership of the vec with all instructions
    </span><span class="macro">assert_eq!</span>(instrs.len(), <span class="number">19</span>);
    <span class="macro">assert_eq!</span>(a.instructions().len(), <span class="number">0</span>);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="disassemble-with-a-symbol-resolver"><a class="doc-anchor" href="#disassemble-with-a-symbol-resolver">§</a>Disassemble with a symbol resolver</h3>
<p>Creates a custom <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/trait.SymbolResolver.html"><code>SymbolResolver</code></a> that is called by a <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/trait.Formatter.html"><code>Formatter</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>iced_x86::{
    Decoder, DecoderOptions, Formatter, Instruction, MasmFormatter, SymbolResolver, SymbolResult,
};
<span class="kw">use </span>std::collections::HashMap;

<span class="kw">struct </span>MySymbolResolver {
    map: HashMap&lt;u64, String&gt;,
}

<span class="kw">impl </span>SymbolResolver <span class="kw">for </span>MySymbolResolver {
    <span class="kw">fn </span>symbol(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>, _instruction: <span class="kw-2">&amp;</span>Instruction, _operand: u32, _instruction_operand: <span class="prelude-ty">Option</span>&lt;u32&gt;,
        address: u64, _address_size: u32,
    ) -&gt; <span class="prelude-ty">Option</span>&lt;SymbolResult&gt; {
        <span class="kw">if let </span><span class="prelude-val">Some</span>(symbol_string) = <span class="self">self</span>.map.get(<span class="kw-2">&amp;</span>address) {
            <span class="comment">// The 'address' arg is the address of the symbol and doesn't have to be identical
            // to the 'address' arg passed to symbol(). If it's different from the input
            // address, the formatter will add +N or -N, eg. '[rax+symbol+123]'
            </span><span class="prelude-val">Some</span>(SymbolResult::with_str(address, symbol_string.as_str()))
        } <span class="kw">else </span>{
            <span class="prelude-val">None
        </span>}
    }
}

<span class="attr">#[allow(dead_code)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>how_to_resolve_symbols() {
    <span class="kw">let </span>bytes = <span class="string">b"\x48\x8B\x8A\xA5\x5A\xA5\x5A"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>decoder = Decoder::new(<span class="number">64</span>, bytes, DecoderOptions::NONE);
    <span class="kw">let </span>instr = decoder.decode();

    <span class="kw">let </span><span class="kw-2">mut </span>sym_map: HashMap&lt;u64, String&gt; = HashMap::new();
    sym_map.insert(<span class="number">0x5AA5_5AA5</span>, String::from(<span class="string">"my_data"</span>));

    <span class="kw">let </span><span class="kw-2">mut </span>output = String::new();
    <span class="kw">let </span>resolver = Box::new(MySymbolResolver { map: sym_map });
    <span class="comment">// Create a formatter that uses our symbol resolver
    </span><span class="kw">let </span><span class="kw-2">mut </span>formatter = MasmFormatter::with_options(<span class="prelude-val">Some</span>(resolver), <span class="prelude-val">None</span>);

    <span class="comment">// This will call the symbol resolver for each immediate / displacement
    // it finds in the instruction.
    </span>formatter.format(<span class="kw-2">&amp;</span>instr, <span class="kw-2">&amp;mut </span>output);

    <span class="comment">// Prints: mov rcx,[rdx+my_data]
    </span><span class="macro">println!</span>(<span class="string">"{}"</span>, output);
}</code></pre></div>
<h3 id="disassemble-with-colorized-text"><a class="doc-anchor" href="#disassemble-with-colorized-text">§</a>Disassemble with colorized text</h3>
<p>Creates a custom <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/trait.FormatterOutput.html"><code>FormatterOutput</code></a> that is called by a <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/trait.Formatter.html"><code>Formatter</code></a>.</p>
<p>This example will fail to compile unless you install the <code>colored</code> crate, see below.</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// This example uses crate colored = "2.0.0"
</span><span class="kw">use </span>colored::{ColoredString, Colorize};
<span class="kw">use </span>iced_x86::{
    Decoder, DecoderOptions, Formatter, FormatterOutput, FormatterTextKind, IntelFormatter,
};

<span class="comment">// Custom formatter output that stores the output in a vector.
</span><span class="kw">struct </span>MyFormatterOutput {
    vec: Vec&lt;(String, FormatterTextKind)&gt;,
}

<span class="kw">impl </span>MyFormatterOutput {
    <span class="kw">pub fn </span>new() -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{ vec: Vec::new() }
    }
}

<span class="kw">impl </span>FormatterOutput <span class="kw">for </span>MyFormatterOutput {
    <span class="kw">fn </span>write(<span class="kw-2">&amp;mut </span><span class="self">self</span>, text: <span class="kw-2">&amp;</span>str, kind: FormatterTextKind) {
        <span class="comment">// This allocates a string. If that's a problem, just call print!() here
        // instead of storing the result in a vector.
        </span><span class="self">self</span>.vec.push((String::from(text), kind));
    }
}

<span class="attr">#[allow(dead_code)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>how_to_colorize_text() {
    <span class="kw">let </span>bytes = EXAMPLE_CODE;
    <span class="kw">let </span><span class="kw-2">mut </span>decoder =
        Decoder::with_ip(EXAMPLE_CODE_BITNESS, bytes, EXAMPLE_CODE_RIP, DecoderOptions::NONE);

    <span class="kw">let </span><span class="kw-2">mut </span>formatter = IntelFormatter::new();
    formatter.options_mut().set_first_operand_char_index(<span class="number">8</span>);
    <span class="kw">let </span><span class="kw-2">mut </span>output = MyFormatterOutput::new();
    <span class="kw">for </span>instruction <span class="kw">in </span><span class="kw-2">&amp;mut </span>decoder {
        output.vec.clear();
        <span class="comment">// The formatter calls output.write() which will update vec with text/colors
        </span>formatter.format(<span class="kw-2">&amp;</span>instruction, <span class="kw-2">&amp;mut </span>output);
        <span class="kw">for </span>(text, kind) <span class="kw">in </span>output.vec.iter() {
            <span class="macro">print!</span>(<span class="string">"{}"</span>, get_color(text.as_str(), <span class="kw-2">*</span>kind));
        }
        <span class="macro">println!</span>();
    }
}

<span class="kw">fn </span>get_color(s: <span class="kw-2">&amp;</span>str, kind: FormatterTextKind) -&gt; ColoredString {
    <span class="kw">match </span>kind {
        FormatterTextKind::Directive | FormatterTextKind::Keyword =&gt; s.bright_yellow(),
        FormatterTextKind::Prefix | FormatterTextKind::Mnemonic =&gt; s.bright_red(),
        FormatterTextKind::Register =&gt; s.bright_blue(),
        FormatterTextKind::Number =&gt; s.bright_cyan(),
        <span class="kw">_ </span>=&gt; s.white(),
    }
}

<span class="kw">const </span>EXAMPLE_CODE_BITNESS: u32 = <span class="number">64</span>;
<span class="kw">const </span>EXAMPLE_CODE_RIP: u64 = <span class="number">0x0000_7FFA_C46A_CDA4</span>;
<span class="kw">static </span>EXAMPLE_CODE: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[
    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x5C</span>, <span class="number">0x24</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x74</span>, <span class="number">0x24</span>, <span class="number">0x18</span>, <span class="number">0x55</span>, <span class="number">0x57</span>, <span class="number">0x41</span>, <span class="number">0x56</span>, <span class="number">0x48</span>, <span class="number">0x8D</span>,
    <span class="number">0xAC</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x48</span>, <span class="number">0x81</span>, <span class="number">0xEC</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x05</span>,
    <span class="number">0x18</span>, <span class="number">0x57</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x33</span>, <span class="number">0xC4</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x85</span>, <span class="number">0xF0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>,
    <span class="number">0x05</span>, <span class="number">0x2F</span>, <span class="number">0x24</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8D</span>, <span class="number">0x05</span>, <span class="number">0x78</span>, <span class="number">0x7C</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x33</span>, <span class="number">0xFF</span>,
];</code></pre></div>
<h3 id="move-code-in-memory-eg-hook-a-function"><a class="doc-anchor" href="#move-code-in-memory-eg-hook-a-function">§</a>Move code in memory (eg. hook a function)</h3>
<p>Uses instruction info API and the encoder to patch a function to jump to the programmer’s function.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>iced_x86::{
    BlockEncoder, BlockEncoderOptions, Code, Decoder, DecoderOptions, FlowControl, Formatter,
    IcedError, Instruction, InstructionBlock, NasmFormatter, OpKind,
};

<span class="comment">// Decodes instructions from some address, then encodes them starting at some
// other address. This can be used to hook a function. You decode enough instructions
// until you have enough bytes to add a JMP instruction that jumps to your code.
// Your code will then conditionally jump to the original code that you re-encoded.
//
// This code uses the BlockEncoder which will help with some things, eg. converting
// short branches to longer branches if the target is too far away.
//
// 64-bit mode also supports RIP relative addressing, but the encoder can't rewrite
// those to use a longer displacement. If any of the moved instructions have RIP
// relative addressing and it tries to access data too far away, the encoder will fail.
// The easiest solution is to use OS alloc functions that allocate memory close to the
// original code (+/-2GB).

/*
This method produces the following output:
Original code:
00007FFAC46ACDA4 mov [rsp+10h],rbx
00007FFAC46ACDA9 mov [rsp+18h],rsi
00007FFAC46ACDAE push rbp
00007FFAC46ACDAF push rdi
00007FFAC46ACDB0 push r14
00007FFAC46ACDB2 lea rbp,[rsp-100h]
00007FFAC46ACDBA sub rsp,200h
00007FFAC46ACDC1 mov rax,[rel 7FFAC47524E0h]
00007FFAC46ACDC8 xor rax,rsp
00007FFAC46ACDCB mov [rbp+0F0h],rax
00007FFAC46ACDD2 mov r8,[rel 7FFAC474F208h]
00007FFAC46ACDD9 lea rax,[rel 7FFAC46F4A58h]
00007FFAC46ACDE0 xor edi,edi

Original + patched code:
00007FFAC46ACDA4 mov rax,123456789ABCDEF0h
00007FFAC46ACDAE jmp rax
00007FFAC46ACDB0 push r14
00007FFAC46ACDB2 lea rbp,[rsp-100h]
00007FFAC46ACDBA sub rsp,200h
00007FFAC46ACDC1 mov rax,[rel 7FFAC47524E0h]
00007FFAC46ACDC8 xor rax,rsp
00007FFAC46ACDCB mov [rbp+0F0h],rax
00007FFAC46ACDD2 mov r8,[rel 7FFAC474F208h]
00007FFAC46ACDD9 lea rax,[rel 7FFAC46F4A58h]
00007FFAC46ACDE0 xor edi,edi

Moved code:
00007FFAC48ACDA4 mov [rsp+10h],rbx
00007FFAC48ACDA9 mov [rsp+18h],rsi
00007FFAC48ACDAE push rbp
00007FFAC48ACDAF push rdi
00007FFAC48ACDB0 jmp 00007FFAC46ACDB0h
*/
</span><span class="attr">#[allow(dead_code)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>how_to_move_code() -&gt; <span class="prelude-ty">Result</span>&lt;(), IcedError&gt; {
    <span class="kw">let </span>example_code = EXAMPLE_CODE.to_vec();
    <span class="macro">println!</span>(<span class="string">"Original code:"</span>);
    disassemble(<span class="kw-2">&amp;</span>example_code, EXAMPLE_CODE_RIP);

    <span class="kw">let </span><span class="kw-2">mut </span>decoder = Decoder::with_ip(
        EXAMPLE_CODE_BITNESS,
        <span class="kw-2">&amp;</span>example_code,
        EXAMPLE_CODE_RIP,
        DecoderOptions::NONE,
    );

    <span class="comment">// In 64-bit mode, we need 12 bytes to jump to any address:
    //      mov rax,imm64   // 10
    //      jmp rax         // 2
    // We overwrite rax because it's probably not used by the called function.
    // In 32-bit mode, a normal JMP is just 5 bytes
    </span><span class="kw">let </span>required_bytes = <span class="number">10 </span>+ <span class="number">2</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>total_bytes = <span class="number">0</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>orig_instructions: Vec&lt;Instruction&gt; = Vec::new();
    <span class="kw">for </span>instr <span class="kw">in </span><span class="kw-2">&amp;mut </span>decoder {
        orig_instructions.push(instr);
        total_bytes += instr.len() <span class="kw">as </span>u32;
        <span class="kw">if </span>instr.is_invalid() {
            <span class="macro">panic!</span>(<span class="string">"Found garbage"</span>);
        }
        <span class="kw">if </span>total_bytes &gt;= required_bytes {
            <span class="kw">break</span>;
        }

        <span class="kw">match </span>instr.flow_control() {
            FlowControl::Next =&gt; {}

            FlowControl::UnconditionalBranch =&gt; {
                <span class="kw">if </span>instr.op0_kind() == OpKind::NearBranch64 {
                    <span class="kw">let </span>_target = instr.near_branch_target();
                    <span class="comment">// You could check if it's just jumping forward a few bytes and follow it
                    // but this is a simple example so we'll fail.
                </span>}
                <span class="macro">panic!</span>(<span class="string">"Not supported by this simple example"</span>);
            }

            FlowControl::IndirectBranch
            | FlowControl::ConditionalBranch
            | FlowControl::Return
            | FlowControl::Call
            | FlowControl::IndirectCall
            | FlowControl::Interrupt
            | FlowControl::XbeginXabortXend
            | FlowControl::Exception =&gt; <span class="macro">panic!</span>(<span class="string">"Not supported by this simple example"</span>),
        }
    }
    <span class="kw">if </span>total_bytes &lt; required_bytes {
        <span class="macro">panic!</span>(<span class="string">"Not enough bytes!"</span>);
    }
    <span class="macro">assert!</span>(!orig_instructions.is_empty());
    <span class="comment">// Create a JMP instruction that branches to the original code, except those instructions
    // that we'll re-encode. We don't need to do it if it already ends in 'ret'
    </span><span class="kw">let </span>(jmp_back_addr, add) = {
        <span class="kw">let </span>last_instr = orig_instructions.last().unwrap();
        <span class="kw">if </span>last_instr.flow_control() != FlowControl::Return {
            (last_instr.next_ip(), <span class="bool-val">true</span>)
        } <span class="kw">else </span>{
            (last_instr.next_ip(), <span class="bool-val">false</span>)
        }
    };
    <span class="kw">if </span>add {
        orig_instructions.push(Instruction::with_branch(Code::Jmp_rel32_64, jmp_back_addr)<span class="question-mark">?</span>);
    }

    <span class="comment">// Relocate the code to some new location. It can fix short/near branches and
    // convert them to short/near/long forms if needed. This also works even if it's a
    // jrcxz/loop/loopcc instruction which only have short forms.
    //
    // It can currently only fix RIP relative operands if the new location is within 2GB
    // of the target data location.
    //
    // Note that a block is not the same thing as a basic block. A block can contain any
    // number of instructions, including any number of branch instructions. One block
    // should be enough unless you must relocate different blocks to different locations.
    </span><span class="kw">let </span>relocated_base_address = EXAMPLE_CODE_RIP + <span class="number">0x20_0000</span>;
    <span class="kw">let </span>block = InstructionBlock::new(<span class="kw-2">&amp;</span>orig_instructions, relocated_base_address);
    <span class="comment">// This method can also encode more than one block but that's rarely needed, see above comment.
    </span><span class="kw">let </span>result = <span class="kw">match </span>BlockEncoder::encode(decoder.bitness(), block, BlockEncoderOptions::NONE) {
        <span class="prelude-val">Err</span>(err) =&gt; <span class="macro">panic!</span>(<span class="string">"{}"</span>, err),
        <span class="prelude-val">Ok</span>(result) =&gt; result,
    };
    <span class="kw">let </span>new_code = result.code_buffer;

    <span class="comment">// Patch the original code. Pretend that we use some OS API to write to memory...
    // We could use the BlockEncoder/Encoder for this but it's easy to do yourself too.
    // This is 'mov rax,imm64; jmp rax'
    </span><span class="kw">const </span>YOUR_FUNC: u64 = <span class="number">0x1234_5678_9ABC_DEF0</span>; <span class="comment">// Address of your code
    </span><span class="kw">let </span><span class="kw-2">mut </span>example_code = example_code.to_vec();
    example_code[<span class="number">0</span>] = <span class="number">0x48</span>; <span class="comment">// \ 'MOV RAX,imm64'
    </span>example_code[<span class="number">1</span>] = <span class="number">0xB8</span>; <span class="comment">// /
    </span><span class="kw">let </span><span class="kw-2">mut </span>v = YOUR_FUNC;
    <span class="kw">for </span>p <span class="kw">in </span><span class="kw-2">&amp;mut </span>example_code[<span class="number">2</span>..<span class="number">10</span>] {
        <span class="kw-2">*</span>p = v <span class="kw">as </span>u8;
        v &gt;&gt;= <span class="number">8</span>;
    }
    example_code[<span class="number">10</span>] = <span class="number">0xFF</span>; <span class="comment">// \ JMP RAX
    </span>example_code[<span class="number">11</span>] = <span class="number">0xE0</span>; <span class="comment">// /

    // Disassemble it
    </span><span class="macro">println!</span>(<span class="string">"Original + patched code:"</span>);
    disassemble(<span class="kw-2">&amp;</span>example_code, EXAMPLE_CODE_RIP);

    <span class="comment">// Disassemble the moved code
    </span><span class="macro">println!</span>(<span class="string">"Moved code:"</span>);
    disassemble(<span class="kw-2">&amp;</span>new_code, relocated_base_address);

	<span class="prelude-val">Ok</span>(())
}

<span class="kw">fn </span>disassemble(data: <span class="kw-2">&amp;</span>[u8], ip: u64) {
    <span class="kw">let </span><span class="kw-2">mut </span>formatter = NasmFormatter::new();
    <span class="kw">let </span><span class="kw-2">mut </span>output = String::new();
    <span class="kw">let </span><span class="kw-2">mut </span>decoder = Decoder::with_ip(EXAMPLE_CODE_BITNESS, data, ip, DecoderOptions::NONE);
    <span class="kw">for </span>instruction <span class="kw">in </span><span class="kw-2">&amp;mut </span>decoder {
        output.clear();
        formatter.format(<span class="kw-2">&amp;</span>instruction, <span class="kw-2">&amp;mut </span>output);
        <span class="macro">println!</span>(<span class="string">"{:016X} {}"</span>, instruction.ip(), output);
    }
    <span class="macro">println!</span>();
}

<span class="kw">const </span>EXAMPLE_CODE_BITNESS: u32 = <span class="number">64</span>;
<span class="kw">const </span>EXAMPLE_CODE_RIP: u64 = <span class="number">0x0000_7FFA_C46A_CDA4</span>;
<span class="kw">static </span>EXAMPLE_CODE: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[
    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x5C</span>, <span class="number">0x24</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x74</span>, <span class="number">0x24</span>, <span class="number">0x18</span>, <span class="number">0x55</span>, <span class="number">0x57</span>, <span class="number">0x41</span>, <span class="number">0x56</span>, <span class="number">0x48</span>, <span class="number">0x8D</span>,
    <span class="number">0xAC</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x48</span>, <span class="number">0x81</span>, <span class="number">0xEC</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x05</span>,
    <span class="number">0x18</span>, <span class="number">0x57</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x33</span>, <span class="number">0xC4</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x85</span>, <span class="number">0xF0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>,
    <span class="number">0x05</span>, <span class="number">0x2F</span>, <span class="number">0x24</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8D</span>, <span class="number">0x05</span>, <span class="number">0x78</span>, <span class="number">0x7C</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x33</span>, <span class="number">0xFF</span>,
];</code></pre></div>
<h3 id="get-instruction-info-eg-readwritten-regsmem-control-flow-info-etc"><a class="doc-anchor" href="#get-instruction-info-eg-readwritten-regsmem-control-flow-info-etc">§</a>Get instruction info, eg. read/written regs/mem, control flow info, etc</h3>
<p>Shows how to get used registers/memory and other info. It uses <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.Instruction.html"><code>Instruction</code></a> methods
and an <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.InstructionInfoFactory.html"><code>InstructionInfoFactory</code></a> to get this info.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>iced_x86::{
    ConditionCode, Decoder, DecoderOptions, Instruction, InstructionInfoFactory, OpKind, RflagsBits,
};

<span class="comment">/*
This method produces the following output:
00007FFAC46ACDA4 mov [rsp+10h],rbx
    OpCode: o64 89 /r
    Instruction: MOV r/m64, r64
    Encoding: Legacy
    Mnemonic: Mov
    Code: Mov_rm64_r64
    CpuidFeature: X64
    FlowControl: Next
    Displacement offset = 4, size = 1
    Memory size: 8
    Op0Access: Write
    Op1Access: Read
    Op0: r64_or_mem
    Op1: r64_reg
    Used reg: RSP:Read
    Used reg: RBX:Read
    Used mem: [SS:RSP+0x10;UInt64;Write]
00007FFAC46ACDA9 mov [rsp+18h],rsi
    OpCode: o64 89 /r
    Instruction: MOV r/m64, r64
    Encoding: Legacy
    Mnemonic: Mov
    Code: Mov_rm64_r64
    CpuidFeature: X64
    FlowControl: Next
    Displacement offset = 4, size = 1
    Memory size: 8
    Op0Access: Write
    Op1Access: Read
    Op0: r64_or_mem
    Op1: r64_reg
    Used reg: RSP:Read
    Used reg: RSI:Read
    Used mem: [SS:RSP+0x18;UInt64;Write]
00007FFAC46ACDAE push rbp
    OpCode: o64 50+ro
    Instruction: PUSH r64
    Encoding: Legacy
    Mnemonic: Push
    Code: Push_r64
    CpuidFeature: X64
    FlowControl: Next
    SP Increment: -8
    Op0Access: Read
    Op0: r64_opcode
    Used reg: RBP:Read
    Used reg: RSP:ReadWrite
    Used mem: [SS:RSP+0xFFFFFFFFFFFFFFF8;UInt64;Write]
00007FFAC46ACDAF push rdi
    OpCode: o64 50+ro
    Instruction: PUSH r64
    Encoding: Legacy
    Mnemonic: Push
    Code: Push_r64
    CpuidFeature: X64
    FlowControl: Next
    SP Increment: -8
    Op0Access: Read
    Op0: r64_opcode
    Used reg: RDI:Read
    Used reg: RSP:ReadWrite
    Used mem: [SS:RSP+0xFFFFFFFFFFFFFFF8;UInt64;Write]
00007FFAC46ACDB0 push r14
    OpCode: o64 50+ro
    Instruction: PUSH r64
    Encoding: Legacy
    Mnemonic: Push
    Code: Push_r64
    CpuidFeature: X64
    FlowControl: Next
    SP Increment: -8
    Op0Access: Read
    Op0: r64_opcode
    Used reg: R14:Read
    Used reg: RSP:ReadWrite
    Used mem: [SS:RSP+0xFFFFFFFFFFFFFFF8;UInt64;Write]
00007FFAC46ACDB2 lea rbp,[rsp-100h]
    OpCode: o64 8D /r
    Instruction: LEA r64, m
    Encoding: Legacy
    Mnemonic: Lea
    Code: Lea_r64_m
    CpuidFeature: X64
    FlowControl: Next
    Displacement offset = 4, size = 4
    Op0Access: Write
    Op1Access: NoMemAccess
    Op0: r64_reg
    Op1: mem
    Used reg: RBP:Write
    Used reg: RSP:Read
00007FFAC46ACDBA sub rsp,200h
    OpCode: o64 81 /5 id
    Instruction: SUB r/m64, imm32
    Encoding: Legacy
    Mnemonic: Sub
    Code: Sub_rm64_imm32
    CpuidFeature: X64
    FlowControl: Next
    Immediate offset = 3, size = 4
    RFLAGS Written: OF, SF, ZF, AF, CF, PF
    RFLAGS Modified: OF, SF, ZF, AF, CF, PF
    Op0Access: ReadWrite
    Op1Access: Read
    Op0: r64_or_mem
    Op1: imm32sex64
    Used reg: RSP:ReadWrite
00007FFAC46ACDC1 mov rax,[7FFAC47524E0h]
    OpCode: o64 8B /r
    Instruction: MOV r64, r/m64
    Encoding: Legacy
    Mnemonic: Mov
    Code: Mov_r64_rm64
    CpuidFeature: X64
    FlowControl: Next
    Displacement offset = 3, size = 4
    Memory size: 8
    Op0Access: Write
    Op1Access: Read
    Op0: r64_reg
    Op1: r64_or_mem
    Used reg: RAX:Write
    Used mem: [DS:0x7FFAC47524E0;UInt64;Read]
00007FFAC46ACDC8 xor rax,rsp
    OpCode: o64 33 /r
    Instruction: XOR r64, r/m64
    Encoding: Legacy
    Mnemonic: Xor
    Code: Xor_r64_rm64
    CpuidFeature: X64
    FlowControl: Next
    RFLAGS Written: SF, ZF, PF
    RFLAGS Cleared: OF, CF
    RFLAGS Undefined: AF
    RFLAGS Modified: OF, SF, ZF, AF, CF, PF
    Op0Access: ReadWrite
    Op1Access: Read
    Op0: r64_reg
    Op1: r64_or_mem
    Used reg: RAX:ReadWrite
    Used reg: RSP:Read
00007FFAC46ACDCB mov [rbp+0F0h],rax
    OpCode: o64 89 /r
    Instruction: MOV r/m64, r64
    Encoding: Legacy
    Mnemonic: Mov
    Code: Mov_rm64_r64
    CpuidFeature: X64
    FlowControl: Next
    Displacement offset = 3, size = 4
    Memory size: 8
    Op0Access: Write
    Op1Access: Read
    Op0: r64_or_mem
    Op1: r64_reg
    Used reg: RBP:Read
    Used reg: RAX:Read
    Used mem: [SS:RBP+0xF0;UInt64;Write]
00007FFAC46ACDD2 mov r8,[7FFAC474F208h]
    OpCode: o64 8B /r
    Instruction: MOV r64, r/m64
    Encoding: Legacy
    Mnemonic: Mov
    Code: Mov_r64_rm64
    CpuidFeature: X64
    FlowControl: Next
    Displacement offset = 3, size = 4
    Memory size: 8
    Op0Access: Write
    Op1Access: Read
    Op0: r64_reg
    Op1: r64_or_mem
    Used reg: R8:Write
    Used mem: [DS:0x7FFAC474F208;UInt64;Read]
00007FFAC46ACDD9 lea rax,[7FFAC46F4A58h]
    OpCode: o64 8D /r
    Instruction: LEA r64, m
    Encoding: Legacy
    Mnemonic: Lea
    Code: Lea_r64_m
    CpuidFeature: X64
    FlowControl: Next
    Displacement offset = 3, size = 4
    Op0Access: Write
    Op1Access: NoMemAccess
    Op0: r64_reg
    Op1: mem
    Used reg: RAX:Write
00007FFAC46ACDE0 xor edi,edi
    OpCode: o32 33 /r
    Instruction: XOR r32, r/m32
    Encoding: Legacy
    Mnemonic: Xor
    Code: Xor_r32_rm32
    CpuidFeature: INTEL386
    FlowControl: Next
    RFLAGS Cleared: OF, SF, CF
    RFLAGS Set: ZF, PF
    RFLAGS Undefined: AF
    RFLAGS Modified: OF, SF, ZF, AF, CF, PF
    Op0Access: Write
    Op1Access: None
    Op0: r32_reg
    Op1: r32_or_mem
    Used reg: RDI:Write
*/
</span><span class="attr">#[allow(dead_code)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>how_to_get_instruction_info() {
    <span class="kw">let </span><span class="kw-2">mut </span>decoder = Decoder::with_ip(
        EXAMPLE_CODE_BITNESS,
        EXAMPLE_CODE,
        EXAMPLE_CODE_RIP,
        DecoderOptions::NONE,
    );

    <span class="comment">// Use a factory to create the instruction info if you need register and
    // memory usage. If it's something else, eg. encoding, flags, etc, there
    // are Instruction methods that can be used instead.
    </span><span class="kw">let </span><span class="kw-2">mut </span>info_factory = InstructionInfoFactory::new();
    <span class="kw">let </span><span class="kw-2">mut </span>instr = Instruction::default();
    <span class="kw">while </span>decoder.can_decode() {
        decoder.decode_out(<span class="kw-2">&amp;mut </span>instr);

        <span class="comment">// Gets offsets in the instruction of the displacement and immediates and their sizes.
        // This can be useful if there are relocations in the binary. The encoder has a similar
        // method. This method must be called after decode() and you must pass in the last
        // instruction decode() returned.
        </span><span class="kw">let </span>offsets = decoder.get_constant_offsets(<span class="kw-2">&amp;</span>instr);

        <span class="comment">// For quick hacks, it's fine to use the Display trait to format an instruction,
        // but for real code, use a formatter, eg. MasmFormatter. See other examples.
        </span><span class="macro">println!</span>(<span class="string">"{:016X} {}"</span>, instr.ip(), instr);

        <span class="kw">let </span>op_code = instr.op_code();
        <span class="kw">let </span>info = info_factory.info(<span class="kw-2">&amp;</span>instr);
        <span class="kw">let </span>fpu_info = instr.fpu_stack_increment_info();
        <span class="macro">println!</span>(<span class="string">"    OpCode: {}"</span>, op_code.op_code_string());
        <span class="macro">println!</span>(<span class="string">"    Instruction: {}"</span>, op_code.instruction_string());
        <span class="macro">println!</span>(<span class="string">"    Encoding: {:?}"</span>, instr.encoding());
        <span class="macro">println!</span>(<span class="string">"    Mnemonic: {:?}"</span>, instr.mnemonic());
        <span class="macro">println!</span>(<span class="string">"    Code: {:?}"</span>, instr.code());
        <span class="macro">println!</span>(
            <span class="string">"    CpuidFeature: {}"</span>,
            instr
                .cpuid_features()
                .iter()
                .map(|<span class="kw-2">&amp;</span>a| <span class="macro">format!</span>(<span class="string">"{:?}"</span>, a))
                .collect::&lt;Vec&lt;String&gt;&gt;()
                .join(<span class="string">" and "</span>)
        );
        <span class="macro">println!</span>(<span class="string">"    FlowControl: {:?}"</span>, instr.flow_control());
        <span class="kw">if </span>fpu_info.writes_top() {
            <span class="kw">if </span>fpu_info.increment() == <span class="number">0 </span>{
                <span class="macro">println!</span>(<span class="string">"    FPU TOP: the instruction overwrites TOP"</span>);
            } <span class="kw">else </span>{
                <span class="macro">println!</span>(<span class="string">"    FPU TOP inc: {}"</span>, fpu_info.increment());
            }
            <span class="macro">println!</span>(
                <span class="string">"    FPU TOP cond write: {}"</span>,
                <span class="kw">if </span>fpu_info.conditional() { <span class="string">"true" </span>} <span class="kw">else </span>{ <span class="string">"false" </span>}
            );
        }
        <span class="kw">if </span>offsets.has_displacement() {
            <span class="macro">println!</span>(
                <span class="string">"    Displacement offset = {}, size = {}"</span>,
                offsets.displacement_offset(),
                offsets.displacement_size()
            );
        }
        <span class="kw">if </span>offsets.has_immediate() {
            <span class="macro">println!</span>(
                <span class="string">"    Immediate offset = {}, size = {}"</span>,
                offsets.immediate_offset(),
                offsets.immediate_size()
            );
        }
        <span class="kw">if </span>offsets.has_immediate2() {
            <span class="macro">println!</span>(
                <span class="string">"    Immediate #2 offset = {}, size = {}"</span>,
                offsets.immediate_offset2(),
                offsets.immediate_size2()
            );
        }
        <span class="kw">if </span>instr.is_stack_instruction() {
            <span class="macro">println!</span>(<span class="string">"    SP Increment: {}"</span>, instr.stack_pointer_increment());
        }
        <span class="kw">if </span>instr.condition_code() != ConditionCode::None {
            <span class="macro">println!</span>(<span class="string">"    Condition code: {:?}"</span>, instr.condition_code());
        }
        <span class="kw">if </span>instr.rflags_read() != RflagsBits::NONE {
            <span class="macro">println!</span>(<span class="string">"    RFLAGS Read: {}"</span>, flags(instr.rflags_read()));
        }
        <span class="kw">if </span>instr.rflags_written() != RflagsBits::NONE {
            <span class="macro">println!</span>(<span class="string">"    RFLAGS Written: {}"</span>, flags(instr.rflags_written()));
        }
        <span class="kw">if </span>instr.rflags_cleared() != RflagsBits::NONE {
            <span class="macro">println!</span>(<span class="string">"    RFLAGS Cleared: {}"</span>, flags(instr.rflags_cleared()));
        }
        <span class="kw">if </span>instr.rflags_set() != RflagsBits::NONE {
            <span class="macro">println!</span>(<span class="string">"    RFLAGS Set: {}"</span>, flags(instr.rflags_set()));
        }
        <span class="kw">if </span>instr.rflags_undefined() != RflagsBits::NONE {
            <span class="macro">println!</span>(<span class="string">"    RFLAGS Undefined: {}"</span>, flags(instr.rflags_undefined()));
        }
        <span class="kw">if </span>instr.rflags_modified() != RflagsBits::NONE {
            <span class="macro">println!</span>(<span class="string">"    RFLAGS Modified: {}"</span>, flags(instr.rflags_modified()));
        }
        <span class="kw">if </span>instr.op_kinds().any(|op_kind| op_kind == OpKind::Memory) {
            <span class="kw">let </span>size = instr.memory_size().size();
            <span class="kw">if </span>size != <span class="number">0 </span>{
                <span class="macro">println!</span>(<span class="string">"    Memory size: {}"</span>, size);
            }
        }
        <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..instr.op_count() {
            <span class="macro">println!</span>(<span class="string">"    Op{}Access: {:?}"</span>, i, info.op_access(i));
        }
        <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..op_code.op_count() {
            <span class="macro">println!</span>(<span class="string">"    Op{}: {:?}"</span>, i, op_code.op_kind(i));
        }
        <span class="kw">for </span>reg_info <span class="kw">in </span>info.used_registers() {
            <span class="macro">println!</span>(<span class="string">"    Used reg: {:?}"</span>, reg_info);
        }
        <span class="kw">for </span>mem_info <span class="kw">in </span>info.used_memory() {
            <span class="macro">println!</span>(<span class="string">"    Used mem: {:?}"</span>, mem_info);
        }
    }
}

<span class="kw">fn </span>flags(rf: u32) -&gt; String {
    <span class="kw">fn </span>append(sb: <span class="kw-2">&amp;mut </span>String, s: <span class="kw-2">&amp;</span>str) {
        <span class="kw">if </span>!sb.is_empty() {
            sb.push_str(<span class="string">", "</span>);
        }
        sb.push_str(s);
    }

    <span class="kw">let </span><span class="kw-2">mut </span>sb = String::new();
    <span class="kw">if </span>(rf &amp; RflagsBits::OF) != <span class="number">0 </span>{
        append(<span class="kw-2">&amp;mut </span>sb, <span class="string">"OF"</span>);
    }
    <span class="kw">if </span>(rf &amp; RflagsBits::SF) != <span class="number">0 </span>{
        append(<span class="kw-2">&amp;mut </span>sb, <span class="string">"SF"</span>);
    }
    <span class="kw">if </span>(rf &amp; RflagsBits::ZF) != <span class="number">0 </span>{
        append(<span class="kw-2">&amp;mut </span>sb, <span class="string">"ZF"</span>);
    }
    <span class="kw">if </span>(rf &amp; RflagsBits::AF) != <span class="number">0 </span>{
        append(<span class="kw-2">&amp;mut </span>sb, <span class="string">"AF"</span>);
    }
    <span class="kw">if </span>(rf &amp; RflagsBits::CF) != <span class="number">0 </span>{
        append(<span class="kw-2">&amp;mut </span>sb, <span class="string">"CF"</span>);
    }
    <span class="kw">if </span>(rf &amp; RflagsBits::PF) != <span class="number">0 </span>{
        append(<span class="kw-2">&amp;mut </span>sb, <span class="string">"PF"</span>);
    }
    <span class="kw">if </span>(rf &amp; RflagsBits::DF) != <span class="number">0 </span>{
        append(<span class="kw-2">&amp;mut </span>sb, <span class="string">"DF"</span>);
    }
    <span class="kw">if </span>(rf &amp; RflagsBits::IF) != <span class="number">0 </span>{
        append(<span class="kw-2">&amp;mut </span>sb, <span class="string">"IF"</span>);
    }
    <span class="kw">if </span>(rf &amp; RflagsBits::AC) != <span class="number">0 </span>{
        append(<span class="kw-2">&amp;mut </span>sb, <span class="string">"AC"</span>);
    }
    <span class="kw">if </span>(rf &amp; RflagsBits::UIF) != <span class="number">0 </span>{
        append(<span class="kw-2">&amp;mut </span>sb, <span class="string">"UIF"</span>);
    }
    <span class="kw">if </span>sb.is_empty() {
        sb.push_str(<span class="string">"&lt;empty&gt;"</span>);
    }
    sb
}

<span class="kw">const </span>EXAMPLE_CODE_BITNESS: u32 = <span class="number">64</span>;
<span class="kw">const </span>EXAMPLE_CODE_RIP: u64 = <span class="number">0x0000_7FFA_C46A_CDA4</span>;
<span class="kw">static </span>EXAMPLE_CODE: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[
    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x5C</span>, <span class="number">0x24</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x74</span>, <span class="number">0x24</span>, <span class="number">0x18</span>, <span class="number">0x55</span>, <span class="number">0x57</span>, <span class="number">0x41</span>, <span class="number">0x56</span>, <span class="number">0x48</span>, <span class="number">0x8D</span>,
    <span class="number">0xAC</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x48</span>, <span class="number">0x81</span>, <span class="number">0xEC</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x05</span>,
    <span class="number">0x18</span>, <span class="number">0x57</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x33</span>, <span class="number">0xC4</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x85</span>, <span class="number">0xF0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>,
    <span class="number">0x05</span>, <span class="number">0x2F</span>, <span class="number">0x24</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8D</span>, <span class="number">0x05</span>, <span class="number">0x78</span>, <span class="number">0x7C</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x33</span>, <span class="number">0xFF</span>,
];</code></pre></div>
<h3 id="get-the-virtual-address-of-a-memory-operand"><a class="doc-anchor" href="#get-the-virtual-address-of-a-memory-operand">§</a>Get the virtual address of a memory operand</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>iced_x86::{Decoder, DecoderOptions, Register};

<span class="attr">#[allow(dead_code)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>how_to_get_virtual_address() {
    <span class="comment">// add [rdi+r12*8-5AA5EDCCh],esi
    </span><span class="kw">let </span>bytes = <span class="string">b"\x42\x01\xB4\xE7\x34\x12\x5A\xA5"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>decoder = Decoder::new(<span class="number">64</span>, bytes, DecoderOptions::NONE);
    <span class="kw">let </span>instr = decoder.decode();

    <span class="kw">let </span>va = instr.virtual_address(<span class="number">0</span>, <span class="number">0</span>, |register, _element_index, _element_size| {
        <span class="kw">match </span>register {
            <span class="comment">// The base address of ES, CS, SS and DS is always 0 in 64-bit mode
            </span>Register::ES | Register::CS | Register::SS | Register::DS =&gt; <span class="prelude-val">Some</span>(<span class="number">0</span>),
            Register::RDI =&gt; <span class="prelude-val">Some</span>(<span class="number">0x0000_0000_1000_0000</span>),
            Register::R12 =&gt; <span class="prelude-val">Some</span>(<span class="number">0x0000_0004_0000_0000</span>),
            <span class="kw">_ </span>=&gt; <span class="prelude-val">None</span>,
        }
    });
    <span class="macro">assert_eq!</span>(va, <span class="prelude-val">Some</span>(<span class="number">0x0000_001F_B55A_1234</span>));
}</code></pre></div>
<h3 id="disassemble-olddeprecated-cpu-instructions"><a class="doc-anchor" href="#disassemble-olddeprecated-cpu-instructions">§</a>Disassemble old/deprecated CPU instructions</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>iced_x86::{Decoder, DecoderOptions, Formatter, Instruction, NasmFormatter};

<span class="comment">/*
This method produces the following output:
731E0A03 bndmov bnd1, [eax]
731E0A07 mov tr3, esi
731E0A0A rdshr [eax]
731E0A0D dmint
731E0A0F svdc [eax], cs
731E0A12 cpu_read
731E0A14 pmvzb mm1, [eax]
731E0A17 frinear
731E0A19 altinst
*/
</span><span class="attr">#[allow(dead_code)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>how_to_disassemble_old_instrs() {
    <span class="attr">#[rustfmt::skip]
    </span><span class="kw">let </span>bytes = <span class="kw-2">&amp;</span>[
        <span class="comment">// bndmov bnd1,[eax]
        </span><span class="number">0x66</span>, <span class="number">0x0F</span>, <span class="number">0x1A</span>, <span class="number">0x08</span>,
        <span class="comment">// mov tr3,esi
        </span><span class="number">0x0F</span>, <span class="number">0x26</span>, <span class="number">0xDE</span>,
        <span class="comment">// rdshr [eax]
        </span><span class="number">0x0F</span>, <span class="number">0x36</span>, <span class="number">0x00</span>,
        <span class="comment">// dmint
        </span><span class="number">0x0F</span>, <span class="number">0x39</span>,
        <span class="comment">// svdc [eax],cs
        </span><span class="number">0x0F</span>, <span class="number">0x78</span>, <span class="number">0x08</span>,
        <span class="comment">// cpu_read
        </span><span class="number">0x0F</span>, <span class="number">0x3D</span>,
        <span class="comment">// pmvzb mm1,[eax]
        </span><span class="number">0x0F</span>, <span class="number">0x58</span>, <span class="number">0x08</span>,
        <span class="comment">// frinear
        </span><span class="number">0xDF</span>, <span class="number">0xFC</span>,
        <span class="comment">// altinst
        </span><span class="number">0x0F</span>, <span class="number">0x3F</span>,
    ];

    <span class="comment">// Enable decoding of Cyrix/Geode instructions, Centaur ALTINST, MOV to/from TR
    // and MPX instructions.
    // There are other options to enable other instructions such as UMOV, KNC, etc.
    // These are deprecated instructions or only used by old CPUs so they're not
    // enabled by default. Some newer instructions also use the same opcodes as
    // some of these old instructions.
    </span><span class="kw">const </span>DECODER_OPTIONS: u32 = DecoderOptions::MPX
        | DecoderOptions::MOV_TR
        | DecoderOptions::CYRIX
        | DecoderOptions::CYRIX_DMI
        | DecoderOptions::ALTINST;
    <span class="kw">let </span><span class="kw-2">mut </span>decoder = Decoder::with_ip(<span class="number">32</span>, bytes, <span class="number">0x731E_0A03</span>, DECODER_OPTIONS);

    <span class="kw">let </span><span class="kw-2">mut </span>formatter = NasmFormatter::new();
    formatter.options_mut().set_space_after_operand_separator(<span class="bool-val">true</span>);
    <span class="kw">let </span><span class="kw-2">mut </span>output = String::new();

    <span class="kw">let </span><span class="kw-2">mut </span>instruction = Instruction::default();
    <span class="kw">while </span>decoder.can_decode() {
        decoder.decode_out(<span class="kw-2">&amp;mut </span>instruction);

        output.clear();
        formatter.format(<span class="kw-2">&amp;</span>instruction, <span class="kw-2">&amp;mut </span>output);

        <span class="macro">println!</span>(<span class="string">"{:08X} {}"</span>, instruction.ip(), <span class="kw-2">&amp;</span>output);
    }
}</code></pre></div>
<h3 id="disassemble-as-fast-as-possible"><a class="doc-anchor" href="#disassemble-as-fast-as-possible">§</a>Disassemble as fast as possible</h3>
<p>For fastest possible disassembly you should set <a href="https://docs.rs/iced-x86/trait.SpecializedFormatterTraitOptions.html#associatedconstant.ENABLE_DB_DW_DD_DQ"><code>ENABLE_DB_DW_DD_DQ</code></a> to <code>false</code>
and you should also override the unsafe <a href="https://docs.rs/iced-x86/trait.SpecializedFormatterTraitOptions.html#method.verify_output_has_enough_bytes_left"><code>verify_output_has_enough_bytes_left()</code></a> and return <code>false</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>iced_x86::{
    Decoder, DecoderOptions, Instruction, SpecializedFormatter, SpecializedFormatterTraitOptions,
};

<span class="attr">#[allow(dead_code)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>how_to_disassemble_really_fast() {
    <span class="kw">struct </span>MyTraitOptions;
    <span class="kw">impl </span>SpecializedFormatterTraitOptions <span class="kw">for </span>MyTraitOptions {
        <span class="comment">// If you never create a db/dw/dd/dq 'instruction', we don't need this feature.
        </span><span class="kw">const </span>ENABLE_DB_DW_DD_DQ: bool = <span class="bool-val">false</span>;
        <span class="comment">// For a few percent faster code, you can also override `verify_output_has_enough_bytes_left()` and return `false`
        // unsafe fn verify_output_has_enough_bytes_left() -&gt; bool {
        //     false
        // }
    </span>}
    <span class="kw">type </span>MyFormatter = SpecializedFormatter&lt;MyTraitOptions&gt;;

    <span class="comment">// Assume this is a big slice and not just one instruction
    </span><span class="kw">let </span>bytes = <span class="string">b"\x62\xF2\x4F\xDD\x72\x50\x01"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>decoder = Decoder::new(<span class="number">64</span>, bytes, DecoderOptions::NONE);

    <span class="kw">let </span><span class="kw-2">mut </span>output = String::new();
    <span class="kw">let </span><span class="kw-2">mut </span>instruction = Instruction::default();
    <span class="kw">let </span><span class="kw-2">mut </span>formatter = MyFormatter::new();
    <span class="kw">while </span>decoder.can_decode() {
        decoder.decode_out(<span class="kw-2">&amp;mut </span>instruction);
        output.clear();
        formatter.format(<span class="kw-2">&amp;</span>instruction, <span class="kw-2">&amp;mut </span>output);
        <span class="comment">// do something with 'output' here, eg.:
        //     println!("{}", output);
    </span>}
}</code></pre></div>
<p>Also add this to your <code>Cargo.toml</code> file:</p>
<div class="example-wrap"><pre class="language-toml"><code>[profile.release]
codegen-units = 1
lto = true
opt-level = 3</code></pre></div><h3 id="create-and-encode-instructions"><a class="doc-anchor" href="#create-and-encode-instructions">§</a>Create and encode instructions</h3>
<p>NOTE: It’s much easier to just use <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/code_asm/struct.CodeAssembler.html"><code>CodeAssembler</code></a>, see the example above.
This example shows how to create instructions without using it.</p>
<p>This example uses a <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.BlockEncoder.html"><code>BlockEncoder</code></a> to encode created <a href="https://docs.rs/iced-x86/1.21.0/iced_x86/struct.Instruction.html"><code>Instruction</code></a>s.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>iced_x86::{
    BlockEncoder, BlockEncoderOptions, Code, Decoder, DecoderOptions, Formatter, GasFormatter,
    IcedError, Instruction, InstructionBlock, MemoryOperand, Register,
};

<span class="attr">#[allow(dead_code)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>how_to_encode_instructions() -&gt; <span class="prelude-ty">Result</span>&lt;(), IcedError&gt; {
    <span class="kw">let </span>bitness = <span class="number">64</span>;

    <span class="comment">// All created instructions get an IP of 0. The label id is just an IP.
    // The branch instruction's *target* IP should be equal to the IP of the
    // target instruction.
    </span><span class="kw">let </span><span class="kw-2">mut </span>label_id: u64 = <span class="number">1</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>create_label = || {
        <span class="kw">let </span>id = label_id;
        label_id += <span class="number">1</span>;
        id
    };
    <span class="kw">fn </span>add_label(id: u64, <span class="kw-2">mut </span>instruction: Instruction) -&gt; Instruction {
        instruction.set_ip(id);
        instruction
    }

    <span class="kw">let </span>label1 = create_label();

    <span class="kw">let </span><span class="kw-2">mut </span>instructions = <span class="macro">vec!</span>[
        Instruction::with1(Code::Push_r64, Register::RBP)<span class="question-mark">?</span>,
        Instruction::with1(Code::Push_r64, Register::RDI)<span class="question-mark">?</span>,
        Instruction::with1(Code::Push_r64, Register::RSI)<span class="question-mark">?</span>,
        Instruction::with2(Code::Sub_rm64_imm32, Register::RSP, <span class="number">0x50</span>)<span class="question-mark">?</span>,
        Instruction::with(Code::VEX_Vzeroupper),
        Instruction::with2(
            Code::Lea_r64_m,
            Register::RBP,
            MemoryOperand::with_base_displ(Register::RSP, <span class="number">0x60</span>),
        )<span class="question-mark">?</span>,
        Instruction::with2(Code::Mov_r64_rm64, Register::RSI, Register::RCX)<span class="question-mark">?</span>,
        Instruction::with2(
            Code::Lea_r64_m,
            Register::RDI,
            MemoryOperand::with_base_displ(Register::RBP, -<span class="number">0x38</span>),
        )<span class="question-mark">?</span>,
        Instruction::with2(Code::Mov_r32_imm32, Register::ECX, <span class="number">0x0A</span>)<span class="question-mark">?</span>,
        Instruction::with2(Code::Xor_r32_rm32, Register::EAX, Register::EAX)<span class="question-mark">?</span>,
        Instruction::with_rep_stosd(bitness)<span class="question-mark">?</span>,
        Instruction::with2(Code::Cmp_rm64_imm32, Register::RSI, <span class="number">0x1234_5678</span>)<span class="question-mark">?</span>,
        <span class="comment">// Create a branch instruction that references label1
        </span>Instruction::with_branch(Code::Jne_rel32_64, label1)<span class="question-mark">?</span>,
        Instruction::with(Code::Nopd),
        <span class="comment">// Add the instruction that is the target of the branch
        </span>add_label(label1, Instruction::with2(Code::Xor_r32_rm32, Register::R15D, Register::R15D)<span class="question-mark">?</span>),
    ];

    <span class="comment">// Create an instruction that accesses some data using an RIP relative memory operand
    </span><span class="kw">let </span>data1 = create_label();
    instructions.push(Instruction::with2(
        Code::Lea_r64_m,
        Register::R14,
        MemoryOperand::with_base_displ(Register::RIP, data1 <span class="kw">as </span>i64),
    )<span class="question-mark">?</span>);
    instructions.push(Instruction::with(Code::Nopd));
    <span class="kw">let </span>raw_data: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x56</span>, <span class="number">0x78</span>];
    instructions.push(add_label(data1, Instruction::with_declare_byte(raw_data)<span class="question-mark">?</span>));

    <span class="comment">// Use BlockEncoder to encode a block of instructions. This block can contain any
    // number of branches and any number of instructions. It does support encoding more
    // than one block but it's rarely needed.
    // It uses Encoder to encode all instructions.
    // If the target of a branch is too far away, it can fix it to use a longer branch.
    // This can be disabled by enabling some BlockEncoderOptions flags.
    </span><span class="kw">let </span>target_rip = <span class="number">0x0000_1248_FC84_0000</span>;
    <span class="kw">let </span>block = InstructionBlock::new(<span class="kw-2">&amp;</span>instructions, target_rip);
    <span class="kw">let </span>result = <span class="kw">match </span>BlockEncoder::encode(bitness, block, BlockEncoderOptions::NONE) {
        <span class="prelude-val">Err</span>(error) =&gt; <span class="macro">panic!</span>(<span class="string">"Failed to encode it: {}"</span>, error),
        <span class="prelude-val">Ok</span>(result) =&gt; result,
    };

    <span class="comment">// Now disassemble the encoded instructions. Note that the 'jmp near'
    // instruction was turned into a 'jmp short' instruction because we
    // didn't disable branch optimizations.
    </span><span class="kw">let </span>bytes = result.code_buffer;
    <span class="kw">let </span><span class="kw-2">mut </span>output = String::new();
    <span class="kw">let </span>bytes_code = <span class="kw-2">&amp;</span>bytes[<span class="number">0</span>..bytes.len() - raw_data.len()];
    <span class="kw">let </span>bytes_data = <span class="kw-2">&amp;</span>bytes[bytes.len() - raw_data.len()..];
    <span class="kw">let </span><span class="kw-2">mut </span>decoder = Decoder::with_ip(bitness, bytes_code, target_rip, DecoderOptions::NONE);
    <span class="kw">let </span><span class="kw-2">mut </span>formatter = GasFormatter::new();
    formatter.options_mut().set_first_operand_char_index(<span class="number">8</span>);
    <span class="kw">for </span>instruction <span class="kw">in </span><span class="kw-2">&amp;mut </span>decoder {
        output.clear();
        formatter.format(<span class="kw-2">&amp;</span>instruction, <span class="kw-2">&amp;mut </span>output);
        <span class="macro">println!</span>(<span class="string">"{:016X} {}"</span>, instruction.ip(), output);
    }
    <span class="kw">let </span>db = Instruction::with_declare_byte(bytes_data)<span class="question-mark">?</span>;
    output.clear();
    formatter.format(<span class="kw-2">&amp;</span>db, <span class="kw-2">&amp;mut </span>output);
    <span class="macro">println!</span>(<span class="string">"{:016X} {}"</span>, decoder.ip(), output);
    <span class="prelude-val">Ok</span>(())
}
<span class="comment">/*
Output:
00001248FC840000 push    %rbp
00001248FC840001 push    %rdi
00001248FC840002 push    %rsi
00001248FC840003 sub     $0x50,%rsp
00001248FC84000A vzeroupper
00001248FC84000D lea     0x60(%rsp),%rbp
00001248FC840012 mov     %rcx,%rsi
00001248FC840015 lea     -0x38(%rbp),%rdi
00001248FC840019 mov     $0xA,%ecx
00001248FC84001E xor     %eax,%eax
00001248FC840020 rep stos %eax,(%rdi)
00001248FC840022 cmp     $0x12345678,%rsi
00001248FC840029 jne     0x00001248FC84002C
00001248FC84002B nop
00001248FC84002C xor     %r15d,%r15d
00001248FC84002F lea     0x1248FC840037,%r14
00001248FC840036 nop
00001248FC840037 .byte   0x12,0x34,0x56,0x78
*/</span></code></pre></div>
<h3 id="minimum-supported-rustc-version"><a class="doc-anchor" href="#minimum-supported-rustc-version">§</a>Minimum supported <code>rustc</code> version</h3>
<p>iced-x86 supports <code>rustc</code> <code>1.57.0</code> or later.
This is checked in CI builds where the minimum supported version and the latest stable version are used to build the source code and run tests.</p>
<p>Bumping the minimum supported version of <code>rustc</code> is considered a minor breaking change. The minor version of iced-x86 will be incremented.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.ConstantOffsets.html" title="struct iced_x86::ConstantOffsets">Constant<wbr>Offsets</a></dt><dd>Contains the offsets of the displacement and immediate. Call <a href="struct.Decoder.html#method.get_constant_offsets"><code>Decoder::get_constant_offsets()</code></a> or
<a href="struct.Encoder.html#method.get_constant_offsets"><code>Encoder::get_constant_offsets()</code></a> to get the offsets of the constants after the instruction has been
decoded/encoded.</dd><dt><a class="struct" href="struct.Decoder.html" title="struct iced_x86::Decoder">Decoder</a></dt><dd>Decodes 16/32/64-bit x86 instructions</dd><dt><a class="struct" href="struct.DecoderOptions.html" title="struct iced_x86::DecoderOptions">Decoder<wbr>Options</a></dt><dd>Decoder options</dd><dt><a class="struct" href="struct.FormatMnemonicOptions.html" title="struct iced_x86::FormatMnemonicOptions">Format<wbr>Mnemonic<wbr>Options</a></dt><dd>Format mnemonic options</dd><dt><a class="struct" href="struct.FormatterOperandOptions.html" title="struct iced_x86::FormatterOperandOptions">Formatter<wbr>Operand<wbr>Options</a></dt><dd>Operand options</dd><dt><a class="struct" href="struct.FormatterOptions.html" title="struct iced_x86::FormatterOptions">Formatter<wbr>Options</a></dt><dd>Formatter options</dd><dt><a class="struct" href="struct.GasFormatter.html" title="struct iced_x86::GasFormatter">GasFormatter</a></dt><dd>GNU assembler (AT&amp;T) formatter</dd><dt><a class="struct" href="struct.IcedError.html" title="struct iced_x86::IcedError">Iced<wbr>Error</a></dt><dd>iced error</dd><dt><a class="struct" href="struct.Instruction.html" title="struct iced_x86::Instruction">Instruction</a></dt><dd>A 16/32/64-bit x86 instruction. Created by <a href="struct.Decoder.html"><code>Decoder</code></a>, by <a href="code_asm/struct.CodeAssembler.html"><code>CodeAssembler</code></a> or by <code>Instruction::with*()</code> methods.</dd><dt><a class="struct" href="struct.NumberFormattingOptions.html" title="struct iced_x86::NumberFormattingOptions">Number<wbr>Formatting<wbr>Options</a></dt><dd>Gets initialized with the default options and can be overridden by a <a href="trait.FormatterOptionsProvider.html"><code>FormatterOptionsProvider</code></a></dd><dt><a class="struct" href="struct.SymResTextPart.html" title="struct iced_x86::SymResTextPart">SymRes<wbr>Text<wbr>Part</a></dt><dd>Contains text and colors</dd><dt><a class="struct" href="struct.SymbolFlags.html" title="struct iced_x86::SymbolFlags">Symbol<wbr>Flags</a></dt><dd>Symbol flags</dd><dt><a class="struct" href="struct.SymbolResult.html" title="struct iced_x86::SymbolResult">Symbol<wbr>Result</a></dt><dd>Created by a <a href="trait.SymbolResolver.html"><code>SymbolResolver</code></a></dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.CC_a.html" title="enum iced_x86::CC_a">CC_a</a></dt><dd>Mnemonic condition code selector (eg. <code>JA</code> / <code>JNBE</code>)</dd><dt><a class="enum" href="enum.CC_ae.html" title="enum iced_x86::CC_ae">CC_ae</a></dt><dd>Mnemonic condition code selector (eg. <code>JAE</code> / <code>JNB</code> / <code>JNC</code>)</dd><dt><a class="enum" href="enum.CC_b.html" title="enum iced_x86::CC_b">CC_b</a></dt><dd>Mnemonic condition code selector (eg. <code>JB</code> / <code>JC</code> / <code>JNAE</code>)</dd><dt><a class="enum" href="enum.CC_be.html" title="enum iced_x86::CC_be">CC_be</a></dt><dd>Mnemonic condition code selector (eg. <code>JBE</code> / <code>JNA</code>)</dd><dt><a class="enum" href="enum.CC_e.html" title="enum iced_x86::CC_e">CC_e</a></dt><dd>Mnemonic condition code selector (eg. <code>JE</code> / <code>JZ</code>)</dd><dt><a class="enum" href="enum.CC_g.html" title="enum iced_x86::CC_g">CC_g</a></dt><dd>Mnemonic condition code selector (eg. <code>JG</code> / <code>JNLE</code>)</dd><dt><a class="enum" href="enum.CC_ge.html" title="enum iced_x86::CC_ge">CC_ge</a></dt><dd>Mnemonic condition code selector (eg. <code>JGE</code> / <code>JNL</code>)</dd><dt><a class="enum" href="enum.CC_l.html" title="enum iced_x86::CC_l">CC_l</a></dt><dd>Mnemonic condition code selector (eg. <code>JL</code> / <code>JNGE</code>)</dd><dt><a class="enum" href="enum.CC_le.html" title="enum iced_x86::CC_le">CC_le</a></dt><dd>Mnemonic condition code selector (eg. <code>JLE</code> / <code>JNG</code>)</dd><dt><a class="enum" href="enum.CC_ne.html" title="enum iced_x86::CC_ne">CC_ne</a></dt><dd>Mnemonic condition code selector (eg. <code>JNE</code> / <code>JNZ</code>)</dd><dt><a class="enum" href="enum.CC_np.html" title="enum iced_x86::CC_np">CC_np</a></dt><dd>Mnemonic condition code selector (eg. <code>JNP</code> / <code>JPO</code>)</dd><dt><a class="enum" href="enum.CC_p.html" title="enum iced_x86::CC_p">CC_p</a></dt><dd>Mnemonic condition code selector (eg. <code>JP</code> / <code>JPE</code>)</dd><dt><a class="enum" href="enum.Code.html" title="enum iced_x86::Code">Code</a></dt><dd>x86 instruction code</dd><dt><a class="enum" href="enum.CodeSize.html" title="enum iced_x86::CodeSize">Code<wbr>Size</a></dt><dd>The code size (16/32/64) that was used when an instruction was decoded</dd><dt><a class="enum" href="enum.DecoderError.html" title="enum iced_x86::DecoderError">Decoder<wbr>Error</a></dt><dd>Decoder error</dd><dt><a class="enum" href="enum.DecoratorKind.html" title="enum iced_x86::DecoratorKind">Decorator<wbr>Kind</a></dt><dd>Decorator</dd><dt><a class="enum" href="enum.EncodingKind.html" title="enum iced_x86::EncodingKind">Encoding<wbr>Kind</a></dt><dd>Instruction encoding</dd><dt><a class="enum" href="enum.FormatterTextKind.html" title="enum iced_x86::FormatterTextKind">Formatter<wbr>Text<wbr>Kind</a></dt><dd>Formatter text kind</dd><dt><a class="enum" href="enum.MemorySize.html" title="enum iced_x86::MemorySize">Memory<wbr>Size</a></dt><dd>Size of a memory reference</dd><dt><a class="enum" href="enum.MemorySizeOptions.html" title="enum iced_x86::MemorySizeOptions">Memory<wbr>Size<wbr>Options</a></dt><dd>Memory size options used by the formatters</dd><dt><a class="enum" href="enum.Mnemonic.html" title="enum iced_x86::Mnemonic">Mnemonic</a></dt><dd>Mnemonic</dd><dt><a class="enum" href="enum.NumberBase.html" title="enum iced_x86::NumberBase">Number<wbr>Base</a></dt><dd>Number base</dd><dt><a class="enum" href="enum.NumberKind.html" title="enum iced_x86::NumberKind">Number<wbr>Kind</a></dt><dd>Number kind</dd><dt><a class="enum" href="enum.OpKind.html" title="enum iced_x86::OpKind">OpKind</a></dt><dd>Instruction operand kind</dd><dt><a class="enum" href="enum.PrefixKind.html" title="enum iced_x86::PrefixKind">Prefix<wbr>Kind</a></dt><dd>Prefix</dd><dt><a class="enum" href="enum.Register.html" title="enum iced_x86::Register">Register</a></dt><dd>A register</dd><dt><a class="enum" href="enum.RoundingControl.html" title="enum iced_x86::RoundingControl">Rounding<wbr>Control</a></dt><dd>Rounding control</dd><dt><a class="enum" href="enum.SymResString.html" title="enum iced_x86::SymResString">SymRes<wbr>String</a></dt><dd>Contains a <code>&amp;'a str</code> or a <code>String</code></dd><dt><a class="enum" href="enum.SymResTextInfo.html" title="enum iced_x86::SymResTextInfo">SymRes<wbr>Text<wbr>Info</a></dt><dd>Contains one or more <a href="struct.SymResTextPart.html"><code>SymResTextPart</code></a>s (text and color)</dd><dt><a class="enum" href="enum.TupleType.html" title="enum iced_x86::TupleType">Tuple<wbr>Type</a></dt><dd>Tuple type (EVEX/MVEX) which can be used to get the disp8 scale factor <code>N</code></dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Formatter.html" title="trait iced_x86::Formatter">Formatter</a></dt><dd>Formats instructions</dd><dt><a class="trait" href="trait.FormatterOptionsProvider.html" title="trait iced_x86::FormatterOptionsProvider">Formatter<wbr>Options<wbr>Provider</a></dt><dd>Can override options used by a <a href="trait.Formatter.html"><code>Formatter</code></a></dd><dt><a class="trait" href="trait.FormatterOutput.html" title="trait iced_x86::FormatterOutput">Formatter<wbr>Output</a></dt><dd>Used by a <a href="trait.Formatter.html"><code>Formatter</code></a> to write all text. <code>String</code> also implements this trait.</dd><dt><a class="trait" href="trait.SymbolResolver.html" title="trait iced_x86::SymbolResolver">Symbol<wbr>Resolver</a></dt><dd>Used by a <a href="trait.Formatter.html"><code>Formatter</code></a> to resolve symbols</dd></dl></section></div></main></body></html>