searchState.loadedDescShard("acpi", 0, "A library for parsing ACPI tables. This crate can be used …\nError type used by functions that return an <code>AcpiResult&lt;T&gt;</code>.\nResult type used by error-returning functions.\nAll types representing ACPI tables should implement this …\nType capable of enumerating the existing ACPI tables on …\nContains the error value\nThin wrapper around a regular slice, taking a reference to …\nContains the success value\nIterator that steps through all of the tables, and returns …\nACPI defines a Generic Address Structure (GAS), which …\nPhysical address of the start of the AML stream (excluding …\nFinds and returns the DSDT AML table, if it exists.\nSearches through the ACPI table headers and attempts to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an <code>AcpiTables</code> if you have the physical address of …\nCreate an <code>AcpiTables</code> if you have the physical address of …\nCreate an <code>AcpiTables</code> if you have a <code>PhysicalMapping</code> of the …\nIterates through all of the table headers.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLength of the table in bytes.\nLength (in bytes) of the AML stream.\nAttempt to allocate a new <code>ManagedSlice</code> that holds <code>len</code> <code>T</code>s.\nPhysical address of the start of the SDT, including the …\nConvenience method for contructing a <code>PlatformInfo</code>. This is …\nConvenience method for contructing a <code>PlatformInfo</code>. This is …\nThe ACPI revision of the tables enumerated by this …\nSearch for the RSDP on a BIOS platform. This accesses …\nIterates through all of the SSDT tables.\nWhether this SDT has been validated. This is set to <code>true</code> …\nDescribes a register in the configuration space of a PCI …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe BGRT table contains information about a boot graphic …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGets the orientation offset of the image. Degrees are …\nRepresents the Fixed ACPI Description Table (FADT). This …\nIf true, all processors implement the C1 power state.\nIf true, the C2 power state is configured to work on a …\nIf true, the system supports no expansion capabilities and …\nIf true, OSPM <em>must not</em> enable message-signaled interrupts.\nIf true, OSPM <em>must not</em> enable PCIe ASPM control.\nIf true, OSPM <em>must not</em> blindly probe VGA hardware. VGA …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf true, the system implements PSCI.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf true, all LAPICs must be configured using the cluster …\nIf true, legacy user-accessible devices are available on …\nIf true, all LXAPICs must be configured using physical …\nIf true, the motherboard exposes an IO port 60/64 keyboard …\nIf true, the system can achieve equal or better power …\nIf true, the RTC wake status is not supported in fixed …\nIf true, the platform supports OSPM leaving GPE wake …\nAttempts to parse the FADT’s PWM timer blocks, first …\nIf true, indicates that the PM timer is a 32-bit value. If …\nIf true, the power button is handled as a control method …\nIf true, the contents of the <code>RTC_STS</code> register are valid …\nIf true, the RTC alarm function can wake the system from …\nOn systems with an i8259 PIC, this is the vector the …\nIf true, the sleep button is handled as a control method …\nThe system port address of the SMI Command Port. This port …\nIf true, the system supports docking.\nIf true, an equivalent to the x86 WBINVD instruction is …\nIf set, the platform supports the <code>PCIEXP_WAKE_STS</code> and …\nIf true, the system supports system reset via the …\nIf true, the system cannot detect the monitor or …\nIf true, this system is a hardware-reduced ACPI platform, …\nIf true, OSPM must use HVC instead of SMC as the PSCI …\nIf true, OSPM must use a processor instruction after …\nIf true, OSPM should use the ACPI power management timer …\nIf true, OSPM <em>must not</em> use the RTC via its IO ports, …\nIf true, WBINVD properly flushes all caches and  memory …\nThe worst-case latency to enter and exit the C2 state, in …\nThe worst-case latency to enter and exit the C3 state, in …\nAn implementation of this trait must be provided to allow …\nDescribes a physical mapping created by …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGiven a physical address and a size, map a region of …\nConstruct a new <code>PhysicalMapping</code>.\nUnmap the given physical mapping. This is called when a …\nInformation about the High Precision Event Timer (HPET)\nAccess to the rest of the 4KiB, relative to the base …\nAccess to the rest of the 64KiB, relative to the base …\nThe minimum number of clock ticks that can be set without …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis field will appear for ARM processors that support …\nIf this entry is present, the system has an I/O SAPIC, …\nRepresents the MADT - this contains the MADT header …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe GIC version 0x00: Fall back to hardware discovery …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSPE overflow Interrupt.\nConfiguration entry describing a valid bus range for the …\nIterator providing a <code>PciConfigEntry</code> for all of the valid …\nDescribes a set of regions of physical memory used to …\nReturns a slice containing each of the entries in the MCFG …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator providing information about the system…\nGet the physical address of the start of the configuration …\nA processor in this state is unusable, and you must not …\n<code>PlatformInfo</code> allows the collection of some basic …\nInformation about the ACPI Power Management Timer (ACPI PM …\nA Running processor is currently brought up and running …\nA processor waiting for a SIPI (Startup Inter-processor …\nApplication processors should be brought up in the order …\nA generic address to the register block of ACPI PM Timer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this processor is the Bootstrap Processor (BSP), …\nThe ID of the local APIC of the processor. Will be less …\nOn <code>x86_64</code> platforms that support the APIC, the processor …\nCorresponds to the <code>_UID</code> object of the processor’s <code>Device</code>…\nThe state of this processor. Check that the processor is …\nThis field is <code>true</code> if the hardware supports 32-bit timer, …\nWakes up Application Processors (APs) using the …\nDescribes an interrupt controller based around the …\nDescribes a difference in the mapping of an ISA interrupt …\nIndicates which local interrupt line will be utilized by …\nDescribes a Global System Interrupt that should be enabled …\nPolarity indicates what signal mode the interrupt line …\nTrigger mode of an interrupt, describing how the interrupt …\nThis model is only chosen when the MADT does not describe …\nThe physical address at which to access this I/O APIC.\nIf this field is set, you must remap and mask all the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe global system interrupt number where this I/O APIC’s …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe first structure found in ACPI. It just tells us where …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis searches for a RSDP on BIOS systems.\nChecks that: 1) The signature is correct 2) The checksum …\nRepresents a field which may or may not be present within …\nAll SDTs share the same header, and are <code>length</code> bytes long. …\nAccess the field if it’s present for the given revision …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks that:\nAPM88xxxx\nARMH GIC interrupt (Global System Interrupt).\nArm DCC\nArm PL011 UART\nArm SBSA Generic UART\n(deprecated) Arm SBSA (2.x only) Generic UART supporting …\nVCM2835\nDCD required for transmit\nPC-AT-compatible dual-8259 IRQ interrupt.\nFull 16450 interface (must also accept writing to the …\nFull 16550 interface\n16550-compatible with parameters defined in Generic …\nI/O APIC interrupt (Global System Interrupt).\nI/O SAPIC interrupt (Global System Interrupt).\ni.MX 6\nIntel LPSS\nIntel USIF\nMAX311xE SPI UART\nMSM8x60 (e.g. 8960)\nMSM8974\nNvidia 16550\nRISC-V PLIC/APLIC interrupt (Global System Interrupt).\nRTS/CTS hardware flow control\nRISC-V SBI console (any supported SBI mechanism)\nSAM5250\nSDM845 with clock rate of 1.8432 MHz\nSDM845 with clock rate of 7.372 MHz\nSerial Port Console Redirection (SPCR) Table.\nFlow control flags for the UART.\nInterrupt type(s) used by an UART.\nThe terminal protocol the BIOS uses for console …\nTI OMAP\nUnknown interface\nXON/XOFF software control\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nThe base address of the Serial Port register set, if if …\nThe baud rate the BIOS used for redirection, if configured.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nFlow control flags for the UART.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nThe Global System Interrupt (GSIV) used by the UART, if …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGets the type of the register interface.\nInterrupt type(s) used by the UART.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe PC-AT-compatible IRQ used by the UART, if the UART …\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nLanguage which the BIOS was redirecting. Must be 0.\nAn ASCII string to uniquely identify this device. This …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nIf the UART is a PCI device, returns its bus number.\nIf the UART is a PCI device, returns its Device ID.\nIf the UART is a PCI device, returns its device number.\nIf the UART is a PCI device, returns its function number.\nPCI segment number. systems with fewer than 255 PCI buses, …\nIf the UART is a PCI device, returns its Vendor ID.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe terminal protocol the BIOS was using for console …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe UART clock frequency in Hz, if it can be determined.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.")